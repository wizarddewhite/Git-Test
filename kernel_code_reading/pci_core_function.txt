1. pci_create_root_bus()
===============================================================================
pci_create_root_bus(struct device *parent, int bus,
		struct pci_ops *ops, void *sysdata, struct list_head *resources)
	struct pci_host_bridge *host_bridge;
	host_bridge = kzalloc(sizeof(*host_bridge), GFP_KERNEL);

	struct pci_bus *b;
	b = pci_alloc_bus();

	struct device *dev;
	dev = kzalloc(sizeof(*dev), GFP_KERNEL);

	b->sysdata = sysdata;
	b->ops = ops;

	b2 = pci_find_bus(pci_domain_nr(b), bus);
	if (b2) goto err_out;

	dev->parent = parent;
	dev->release = pci_release_bus_bridge_dev;
	dev_set_name(dev, "pci%04x:%02x", pci_domain_nr(b), bus);
	error = device_register(dev);

	b->bridge = get_device(dev);
	device_enable_async_suspend(b->bridge);
	pci_set_bus_of_node(b);

	b->dev.class = &pcibus_class;
	b->dev.parent = b->bridge;
	dev_set_name(&b->dev, "%04x:%02x", pci_domain_nr(b), bus);
	error = device_register(&b->dev);
	pci_create_legacy_files(b);
	b->number = b->secondary = bus;

	host_bridge->bus = b;
	INIT_LIST_HEAD(&host_bridge->windows);

	/* Add initial resources to the bus */
	; add the resource in *resources* list to bus->resources list
	; well for a root bus, the *resources* list is retrieved from
	; hardware, etc, on x86 from ACPI, on power from FDT
	pci_bus_add_resource()

	list_add_tail(&host_bridge->list, &pci_host_bridges);
        list_add_tail(&b->node, &pci_root_buses);
                                                
                                                
                                                
                                                            
       host_bridge(struct pci_host_bridge)      
       +-------------------+                   
       | windows           |                              +->parent(first parameter of 
       +-------------------+                              |         pci_create_root_bus)
       |bus(struct pci_bus)|                              |
       +-------------------+                              +---------------------+
        |                                                                       |
        |                                                                       |
        |                                                 dev(struct device)    |
        |                                           +---->+----------------+    |
        |                                           |     |   parent       |----+
        |    pci_root_bus(struct pci_bus)           |     +----------------+          
        +--->+-------------------------------+      |     |                | 
             |dev(struct device)             |      |     |                |
             |   class = pcibus_class        |      |     +----------------+
             |   parent      ----------------|---+  |
             |                               |   |  |
             +-------------------------------+<--+  |
             |bridge(struct device)          |      |
             |                               |------+
             +-------------------------------+
             |self(struct pci_dev) = NULL    |
             +-------------------------------+
             |number = bus                   |
             +-------------------------------+  
             |secondary = bus                |  
             +-------------------------------+  
             |resources(list_head)           |  
             |     a list of io/mem resource |
             |     available for this bus    |  
             +-------------------------------+  

                Figure 1.1 relationship between pci_root_bus/host_bridge


1.1 pci_bus_add_resource(), add a res to bus->resources list
===============================================================================
pci_bus_add_resource(struct pci_bus *bus, struct resource *res,
			  unsigned int flags)
	struct pci_bus_resource *bus_res;

	bus_res = kzalloc(sizeof(struct pci_bus_resource), GFP_KERNEL);
	if (!bus_res) {
		dev_err(&bus->dev, "can't add %pR resource\n", res);
		return;
	}

	bus_res->res = res;
	bus_res->flags = flags;
	list_add_tail(&bus_res->list, &bus->resources);

2. pci_scan_child_bus(), give the a pci bus, create the sub pci tree
===============================================================================
this is the core function in the pci core to enumerate the pci tree. 
What it will do is:
* bus number assignment and reservation for VFs
* set the pci_dev->resource by reading BAR info
* call pci_read_bridge_bases() for bridge to set the io/mem limit

pci_scan_child_bus(struct pci_bus *bus)
	max = bus->secondary

	/* Go find them, Rover! */
	for (devfn = 0; devfn < 0x100; devfn += 8)
		pci_scan_slot(bus, devfn);

	/* Reserve buses for SR-IOV capability. */
	max += pci_iov_bus_range(bus);

	if (!bus->is_added) {
		dev_dbg(&bus->dev, "fixups for bus\n");
		; this is a platform depent code in which it
		; will call pci_read_bridge_bases() to assign the 
		; bus->resource[]
		pcibios_fixup_bus(bus);
		if (pci_is_root_bus(bus))
			bus->is_added = 1;
	}

	for (pass=0; pass < 2; pass++)
		list_for_each_entry(dev, &bus->devices, bus_list) {
			if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
			    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)
				max = pci_scan_bridge(bus, dev, max, pass);
		}

	return max;

2.2 pci_is_root_bus()
===============================================================================
pci_is_root_bus(struct pci_bus *pbus)
	return !(pbus->parent);

the bus is a root bus when it doesn't have parent.

2.3 pci_scan_slot()
===============================================================================
pci_scan_slot(struct pci_bus *bus, int devfn)
	if (only_one_child(bus) && (devfn > 0))
		return 0; /* Already scanned the entire slot */

	dev = pci_scan_single_device(bus, devfn);
	if (!dev->is_added)
		nr++;

	; calculate fn based on different scheme and call
	pci_scan_single_device(bus, devfn + fn), nr++ if needed

	/* only one slot has pcie device */
	if (bus->self && nr)
		pcie_aspm_init_link_state(bus->self);

	return nr; return the number of newly find pci device

2.4 pci_scan_single_device()
===============================================================================
pci_scan_single_device(struct pci_bus *bus, int devfn)
	struct pci_dev *dev;

	dev = pci_scan_device(bus, devfn);

	pci_device_add(dev, bus);

2.4.1 pci_scan_device()
===============================================================================
pci_scan_device(struct pci_bus *bus, int devfn)
	struct pci_dev *dev;

	dev = alloc_pci_dev();

	dev->bus = bus;
	dev->devfn = devfn;
	dev->vendor = l & 0xffff;
	dev->device = (l >> 16) & 0xffff;

	pci_setup_device(dev);

2.4.1.1 pci_setup_device(), setup the newly found pci_dev
===============================================================================
; set the type, parent, and resource
pci_setup_device(struct pci_dev *dev )
	; get header type, 00h device, 01h bridge, 02h Card Bus
	if (pci_read_config_byte(dev, PCI_HEADER_TYPE, &hdr_type))

	dev->sysdata = dev->bus->sysdata;
	dev->dev.parent = dev->bus->bridge;
	dev->dev.bus = &pci_bus_type;
	dev->hdr_type = hdr_type & 0x7f;

	dev_set_name(&dev->dev, "%04x:%02x:%02x.%d", pci_domain_nr(dev->bus),
		     dev->bus->number, PCI_SLOT(dev->devfn),
		     PCI_FUNC(dev->devfn));

	; early fixups
	pci_fixup_device(pci_fixup_early, dev);

	switch(dev->hdr_typ) { ; three types
	case PCI_HEADER_TYPE_NORMAL:
		pci_read_irq(dev);
		pci_read_bases(dev, 6, PCI_ROM_ADDRESS);
		pci_read_config_word(dev, PCI_SUBSYSTEM_VENDOR_ID, &dev->subsystem_vendor);
		pci_read_config_word(dev, PCI_SUBSYSTEM_ID, &dev->subsystem_device);
	case PCI_HEADER_TYPE_BRIDGE:
		pci_read_irq(dev);
		dev->transparent = ((dev->class & 0xff) == 1);
		pci_read_bases(dev, 2, PCI_ROM_ADDRESS1);
		set_pcie_hotplug_bridge(dev);
		pos = pci_find_capability(dev, PCI_CAP_ID_SSVID);
		if (pos) {
			pci_read_config_word(dev, pos + PCI_SSVID_VENDOR_ID, &dev->subsystem_vendor);
			pci_read_config_word(dev, pos + PCI_SSVID_DEVICE_ID, &dev->subsystem_device);
		}
	case PCI_HEADER_TYPE_CARDBUS:
		pci_read_irq(dev);
		pci_read_bases(dev, 1, 0);
		pci_read_config_word(dev, PCI_CB_SUBSYSTEM_VENDOR_ID, &dev->subsystem_vendor);
		pci_read_config_word(dev, PCI_CB_SUBSYSTEM_ID, &dev->subsystem_device);
	}

	return 0;



               struct pci_dev
               +------------------------------------+
               |dev(struct device)                  |
               |   parent           ----------------|----+ 
               |   bus = &pci_bus_type              |    |
               +------------------------------------+    |
               |bus(pci_bus) attached to which bus  |    |
               |    bridge(device)                  |<---+ 
               +------------------------------------+
               |devfn (device/function number)      |      
               |vendor (vendor ID)                  |      
               |device (device ID)                  |      
               +------------------------------------+
               |resource                            |
               |    (an array of struct resource)   |
               |    retrieve addreess from BAR      |
               |                                    |
               |                                    |
               +------------------------------------+

               Figure 2.1 newly added pci_dev structure


2.4.1.1.1 pci_read_bases(), setup pci_dev->resource from BAR 
===============================================================================
pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
	; howmany/rom is determined by the pci_dev type
	for (pos = 0; pos < howmany; pos++) {
		struct resource *res = &dev->resource[pos];
		reg = PCI_BASE_ADDRESS_0 + (pos << 2);
		pos += __pci_read_base(dev, pci_bar_unknown, res, reg);
	}

	if (rom) {
		struct resource *res = &dev->resource[PCI_ROM_RESOURCE];
		dev->rom_base_reg = rom;
		res->flags = IORESOURCE_MEM | IORESOURCE_PREFETCH |
				IORESOURCE_READONLY | IORESOURCE_CACHEABLE |
				IORESOURCE_SIZEALIGN;
		__pci_read_base(dev, pci_bar_mem32, res, rom);
	}

2.4.2 pci_device_add()
===============================================================================
pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
	device_initialize(&dev->dev);
	dev->dev.release = pci_release_dev;
	pci_dev_get(dev);

	dev->dev.dma_mask = &dev->dma_mask;
	dev->dev.dma_parms = &dev->dma_parms;
	dev->dev.coherent_dma_mask = 0xffffffffull;

	pci_set_dma_max_seg_size(dev, 65536);
	pci_set_dma_seg_boundary(dev, 0xffffffff);

	/* Fix up broken headers */
	pci_fixup_device(pci_fixup_header, dev);

	/* moved out from quirk header fixup code */
	pci_reassigndev_resource_alignment(dev);

	/* Clear the state_saved flag. */
	dev->state_saved = false;

	pci_init_capabilities(dev);

	; add to the bus->devices list
	list_add_tail(&dev->bus_list, &bus->devices);

2.4.2.1 pci_init_capabilities()
===============================================================================
pci_init_capabilities(struct pci_dev *dev)
	/* MSI/MSI-X list */
	pci_msi_init_pci_dev(dev);

	/* Buffers for saving PCIe and PCI-X capabilities */
	pci_allocate_cap_save_buffers(dev);

	/* Power Management */
	pci_pm_init(dev);
	platform_pci_wakeup_init(dev);

	/* Vital Product Data */
	pci_vpd_pci22_init(dev);

	/* Alternative Routing-ID Forwarding */
	pci_enable_ari(dev);

	/* Single Root I/O Virtualization */
	pci_iov_init(dev);

	/* Enable ACS P2P upstream forwarding */
	pci_enable_acs(dev);

2.5 pci_scan_bridge()
===============================================================================
pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 ; bus is the bus where the dev attached to 
 ; dev is a pci_dev whose type is brige or cardbus
 ; max is the max bus number we have met
 ; pass indidate the pass index
 * We need to process bridges in two passes -- first we scan those
 * already configured by the BIOS and after we are done with all of
 * them, we proceed to assigning numbers to the remaining buses in
 * order to avoid overlaps between old and new bus numbers.

 	; for both bridge and cardbus, 0x18-0x1a is the bus number
	; retrieve the bus number from bridge which is set 
	; by firmware
	pci_read_config_dword(dev, PCI_PRIMARY_BUS, &buses);
	primary = buses & 0xFF;
	secondary = (buses >> 8) & 0xFF;
	subordinate = (buses >> 16) & 0xFF;

	; check the bus number
	; 1. primary should equals to bus->number
	; 2. secondary bus number should bigger than primary
	if (!pass &&
	    (primary != bus->number || secondary <= bus->number)) {
		dev_dbg(&dev->dev, "bus configuration invalid, reconfiguring\n");
		broken = 1;
	}

	; disable MasterAbortMode, to do the real work
	pci_write_config_word(dev, PCI_BRIDGE_CONTROL,
			      bctl & ~PCI_BRIDGE_CTL_MASTER_ABORT);


	; pass 0, 
	; the normal case
		child = pci_find_bus(pci_domain_nr(bus), secondary);
		if (!child) {
			child = pci_add_new_bus(bus, dev, secondary);
			if (!child)
				goto out;
			child->primary = primary;
			child->subordinate = subordinate;
			child->bridge_ctl = bctl;
		}

		cmax = pci_scan_child_bus(child);
		if (cmax > max)
			max = cmax;
		if (child->subordinate > max)
			max = child->subordinate;
	
	; pass 1
	; handle the bridge which is not configured well by firmware
		/* Clear errors */
		pci_write_config_word(dev, PCI_STATUS, 0xffff);

		; prevent assigning a bus number that already
		; exist
		child = pci_find_bus(pci_domain_nr(bus), max+1);
		if (!child) {
			child = pci_add_new_bus(bus, dev, ++max);
			if (!child)
				goto out;
		}
		buses = (buses & 0xff000000)
		      | ((unsigned int)(child->primary)     <<  0)
		      | ((unsigned int)(child->secondary)   <<  8)
		      | ((unsigned int)(child->subordinate) << 16);

		; write the device
		pci_write_config_dword(dev, PCI_PRIMARY_BUS, buses);

		pci_fixup_parent_subordinate_busnr(child, max);
		/* Now we can scan all subordinate buses... */
		max = pci_scan_child_bus(child);
		/*
		 * now fix it up again since we have found
		 * the real value of max.
		 */
		pci_fixup_parent_subordinate_busnr(child, max);

		child->subordnate = max;
		pci_write_config_byte(dev, PCI_SUBORDINATE_BUSï¼Œ max);
	return max;

2.5.1 pci_add_new_bus()
===============================================================================
pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev, int busnr)
	struct pci_bus *child;

	child = pci_alloc_child_bus(parent, dev, busnr);
	if (child) {
		down_write(&pci_bus_sem);
		list_add_tail(&child->node, &parent->children);
		up_write(&pci_bus_sem);
	}
	return child;

2.5.1.1 pci_alloc_child_bus()
===============================================================================
pci_alloc_child_bus(struct pci_bus *parent, struct pci_dev *bridge, int busnr)
	child = pci_alloc_bus()

	child->parent = parent;
	child->ops = parent->ops;
	child->sysdata = parent->sysdata;

	child->dev.class = &pcibus_class;
	dev_set_name(&child->dev, ...);

	child->number = child->secondary = busnr;
	child->primary = parent->secondary;
	child->subordinate = 0xff;

	if (!bridge)
		return child;

	child->self = bridge;
	child->bridge = get_device(&bridge->dev);
	pci_set_bus_of_node(child);
	pci_set_bus_speed(child);

	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++) {
		child->resource[i] = &bridge->resource[PCI_BRIDGE_RESOURCES+i];
		child->resource[i]->name = child->name;
	}
	
	; a bridge pci_dev has its subordinate
	bridge->subordinate = child;

	return child;

             -------+---------      Bus 00(pci_bus) <-------------------+
                    |                 +---secondary(00) <---------------|------+
        +-----------+--------+                                          |      |
        |     00:02.0        |P2P bridge(pci_dev)                       |      |
        | PCIe-PCI bridge    |<--------------------------------------------+   |
        +--------------------+                                          |  |   |
        |dev(device)         |<----------------------------------------------+ |
        +---------------------                                          |  | | |
        |subordinate(pci_bus)|----------+                               |  | | |
        +-----------+--------+          |                               |  | | |
                    |                   +------->+--------------------+ |  | | |
                    |                            |parent              |-+  | | |
         +---------------------+  Bus 02(pci_bus)+--------------------+    | | |
         |                     |                 |self(pci_dev)       |----+ | |
         |                     |                 +--------------------+      | |
         |                     |                 |bridge(device)      |------+ |                              
         |                     |                 +--------------------+        |                              
         |                     |                 |primary             |--------+                              
         |                     |                 +--------------------+                                       
         |                     |                 |resource(struct *)  |            
         |                     |                 |  point to corres-  |
    +----v----+           +----v----+            |  ponding bridge res|
    | 02:00.0 |           | 02:01.0 |            |  in self, which is |
    |(pci_dev)|           |(pci_dev)|            |  the bridge        |
    +---------+           +---------+            +--------------------+

                     Figure 2.2 newly added pci_bus and its parent
                     (this is an example, the number could be different)

2.5.2 pci_fixup_parent_subordinate_busnr(), fix parent bus number
===============================================================================
pci_fixup_parent_subordinate_busnr(struct pci_bus *child, int max)
	struct pci_bus *parent = child->parent;

	/* Attempts to fix that up are really dangerous unless
	   we're going to re-assign all bus numbers. */
	if (!pcibios_assign_all_busses())
		return;

	while (parent->parent && parent->subordinate < max) {
		parent->subordinate = max;
		pci_write_config_byte(parent->self, PCI_SUBORDINATE_BUS, max);
		parent = parent->parent;
	}

3. __pci_read_base() read the BAR in config space, set to pci_dev->resource[]
===============================================================================
__pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
		struct resource *res, unsigned int pos)
	; pos is pointed to the BAR position in PCI config space
	; below is to retrieve the BAR address and size
	pci_read_config_dword(dev, pos, &l);
	pci_write_config_dword(dev, pos, l | mask);
	pci_read_config_dword(dev, pos, &sz);
	pci_write_config_dword(dev, pos, l);

	; l is the base address
	; sz is the size

	struct pci_bus_region region;

	region.start = l;
	region.end = l +sz;

	pcibios_bus_to_resource(dev, res, &region);

3.1 pcibios_bus_to_resource(), calculate CPU address of BAR, set to pci_dev->resource
===============================================================================
pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
		strutct pci_bus_region *region)
	struct pci_host_bridge *bridge = pci_host_bridge(dev);
	struct pci_host_bridge_window *window;
	struct pci_bus_region bus_region;
	resource_size_t offset = 0;

	; go throught the bridge window list
	; find the offset
	list_for_each_entry(window, &bridge->windows, list) {
		if (resource_type(res) != resource_type(window->res))
			continue;

		bus_region.start = window->res->start - window->offset;
		bus_region.end = window->res->end - window->offset;

		if (region_contains(&bus_region, region)) {
			offset = window->offset;
			break;
		}
	}

	; set the real CPU address to pci_dev->resource
	res->start = region->start + offset;
	res->end = region->end + offset;

4. pci_find_bus(), find the bus with given domain and bus number
===============================================================================
pci_find_bus(int domain, int busnr)
	while ((bus = pci_find_next_bus(bus)) != NULL)  {
		if (pci_domain_nr(bus) != domain)
			continue;
		tmp_bus = pci_do_find_bus(bus, busnr);
		if (tmp_bus)
			return tmp_bus;
	}
	return NULL;

4.1 pci_find_next_bus()
===============================================================================
pci_find_next_bus(struct pci_bus *from)
	n = from ? from->node.next : pci_root_buses.next;
	if (n != &pci_root_buses)
		b = pci_bus_b(n);
	return b;

4.2 pci_do_find_bus()
===============================================================================
pci_do_find_bus(struct pci_bus *bus, unsigned char busnr)
	if(bus->number == busnr)
		return bus;

	list_for_each(tmp, &bus->children) {
		child = pci_do_find_bus(pci_bus_b(tmp), busnr);
		if(child)
			return child;
	}
	return NULL;

5. pci_bus_add_devices(), go throught the root bus and add devices
===============================================================================
 * Add newly discovered PCI devices (which are on the bus->devices
 * list) to the global PCI device list, add the sysfs and procfs
 * entries.  Where a bridge is found, add the discovered bus to
 * the parents list of child buses, and recurse (breadth-first
 * to be compatible with 2.4)
 	; go throught the devices just under current bus
	; and add to system
	list_for_each_entry(dev, &bus->devices, bus_list) {
		/* Skip already-added devices */
		if (dev->is_added)
			continue;
		retval = pci_bus_add_device(dev);
		if (retval)
			dev_err(&dev->dev, "Error adding device, continuing\n");
	}

	list_for_each_entry(dev, &bus->devices, bus_list) {
		BUG_ON(!dev->is_added);

		child = dev->subordinate;
		/*
		 * If there is an unattached subordinate bus, attach
		 * it and then scan for unattached PCI devices.
		 */
		if (!child)
			continue;
		; add child to parent->children
		if (list_empty(&child->node)) {
			down_write(&pci_bus_sem);
			list_add_tail(&child->node, &dev->bus->children);
			up_write(&pci_bus_sem);
		}
		pci_bus_add_devices(child);

		/*
		 * register the bus with sysfs as the parent is now
		 * properly registered.
		 */
		if (child->is_added)
			continue;
		retval = pci_bus_add_child(child);
		if (retval)
			dev_err(&dev->dev, "Error adding bus, continuing\n");
	}

5.1 pci_bus_add_device(), register pci_dev->dev, create sysfs entry
===============================================================================
pci_bus_add_device(struct pci_dev *dev)
	retval = device_add(&dev->dev);
	if (retval)
		return retval;

	dev->is_added = 1;
	pci_proc_attach_device(dev);
	pci_create_sysfs_dev_files(dev);
	return 0;

5.2 pci_bus_add_child(), register the bus->dev, create sysfs entry
===============================================================================
pci_bus_add_child(struct pci_bus *bus)
	if (bus->bridge)
		bus->dev.parent = bus->bridge;

	retval = device_register(&bus->dev);
	if (retval)
		return retval;

	bus->is_added = 1;

	/* Create legacy_io and legacy_mem files for this bus */
	pci_create_legacy_files(bus);

	return retval;

6. pcie_bus_configure_settings()
===============================================================================
pcie_bus_configure_settings(struct pci_bus *bus, u8 mpss)
	if (!pci_is_pcie(bus->self))
		return;

	if (pcie_bus_config == PCIE_BUS_TUNE_OFF)
		return;

	/* FIXME - Peer to peer DMA is possible, though the endpoint would need
	 * to be aware to the MPS of the destination.  To work around this,
	 * simply force the MPS of the entire system to the smallest possible.
	 */
	if (pcie_bus_config == PCIE_BUS_PEER2PEER)
		smpss = 0;

	if (pcie_bus_config == PCIE_BUS_SAFE) {
		smpss = mpss;

		pcie_find_smpss(bus->self, &smpss);
		pci_walk_bus(bus, pcie_find_smpss, &smpss);
	}

	pcie_bus_configure_set(bus->self, &smpss);
	pci_walk_bus(bus, pcie_bus_configure_set, &smpss);

6.1 pcie_find_smpss()
===============================================================================
pcie_find_smpss(struct pci_dev *dev, void *data)

6.2 pci_walk_bus(), walk devices on/under bus, calling callback
===============================================================================
pci_walk_bus(struct pci_bus *top, int(*cb)(struct pci_dev *, void *),
		void *userdata)
	bus = top;
	next = top->devices.next;
	for (;;) {
		if (next == &bus->devices) {; meet the end of bus->devices
			/* end of this bus, go up or finish */
			if (bus == top)
				break;
			next = bus->self->bus_list.next;
			bus = bus->self->bus;
			continue;
		}
		dev = list_entry(next, struct pci_dev, bus_list);
		if (dev->subordinate) {
			/* this is a pci-pci bridge, do its devices next */
			next = dev->subordinate->devices.next;
			bus = dev->subordinate;
		} else
			next = dev->bus_list.next;

		/* Run device routines with the device locked */
		device_lock(&dev->dev);
		retval = cb(dev, userdata);
		device_unlock(&dev->dev);
		if (retval)
			break;
	}

7. pci_update_resource(), write resource info into bar
===============================================================================
pci_update_resource(struct pci_dev *dev, int resno)
	struct resource *res = dev->resource + resno;
	pcibios_resource_to_bus(dev, &region, res);
	new = region.start | (res->flags & PCI_REGION_FLAG_MASK);
	if (res->flags & IORESOURCE_IO)
		mask = (u32)PCI_BASE_ADDRESS_IO_MASK;
	else
		mask = (u32)PCI_BASE_ADDRESS_MEM_MASK;

	; calculate reg for the real offset in config space
	reg = pci_resource_bar(dev, resno, &type);

	pci_write_config_dword(dev, reg, new);
	pci_read_config_dword(dev, reg, &check);

7.1 pci_resouce_bar(), retrieve the bar offset in config space 
===============================================================================
pci_resource_bar(struct pci_dev *dev, int resno, enum pci_bar_type *type)
	int reg;

	if (resno < PCI_ROM_RESOURCE) {
		*type = pci_bar_unknown;
		return PCI_BASE_ADDRESS_0 + 4 * resno;
	} else if (resno == PCI_ROM_RESOURCE) {
		*type = pci_bar_mem32;
		return dev->rom_base_reg;
	} else if (resno < PCI_BRIDGE_RESOURCES) {
		/* device specific resource */
		reg = pci_iov_resource_bar(dev, resno, type);
		if (reg)
			return reg;
	}

	dev_err(&dev->dev, "BAR %d: invalid resource\n", resno);
	return 0;

8. pci_read_bridge_bases(), for a bridge set its io/mem forward range
===============================================================================
pci_read_bridge_bases(struct pci_bus *child)
	struct pci_dev *dev = child->self;
	struct resource *res;
	int i;

	if (pci_is_root_bus(child))	/* It's a host bus, nothing to read */
		return;

	pci_bus_remove_resources(child);
	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++)
		child->resource[i] = &dev->resource[PCI_BRIDGE_RESOURCES+i];

	pci_read_bridge_io(child);
	pci_read_bridge_mmio(child);
	pci_read_bridge_mmio_pref(child);

	; if this is a transparent bridge, use his parent res
	if (dev->transparent) {
		pci_bus_for_each_resource(child->parent, res, i) {
			if (res) {
				pci_bus_add_resource(child, res,
						     PCI_SUBTRACTIVE_DECODE);
				dev_printk(KERN_DEBUG, &dev->dev,
					   "  bridge window %pR (subtractive decode)\n",
					   res);
			}
		}
	}

8.1 pci_bus_remove_resources(), clean up the resource list
===============================================================================
pci_bus_remove_resources(struct pci_bus *bus)
	int i;

	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++)
		bus->resource[i] = NULL;

	; release the list of bus->resources
	pci_free_resource_list(&bus->resources);


8.2 pci_read_bridge_io(), get io limit
===============================================================================
pci_read_bridge_io(struct pci_bus *child)
	struct pci_dev *dev = child->self;

	res = child->resource[0];
	pci_read_config_byte(dev, PCI_IO_BASE, &io_base_lo);
	pci_read_config_byte(dev, PCI_IO_LIMIT, &io_limit_lo);
	base = (io_base_lo & PCI_IO_RANGE_MASK) << 8;
	limit = (io_limit_lo & PCI_IO_RANGE_MASK) << 8;

	if ((io_base_lo & PCI_IO_RANGE_TYPE_MASK) == PCI_IO_RANGE_TYPE_32) {
		u16 io_base_hi, io_limit_hi;
		pci_read_config_word(dev, PCI_IO_BASE_UPPER16, &io_base_hi);
		pci_read_config_word(dev, PCI_IO_LIMIT_UPPER16, &io_limit_hi);
		base |= (io_base_hi << 16);
		limit |= (io_limit_hi << 16);
	}

	if (base && base <= limit) {
		res->flags = (io_base_lo & PCI_IO_RANGE_TYPE_MASK) | IORESOURCE_IO;
		res2.flags = res->flags;
		region.start = base;
		region.end = limit + 0xfff;
		pcibios_bus_to_resource(dev, &res2, &region);
		if (!res->start)
			res->start = res2.start;
		if (!res->end)
			res->end = res2.end;
		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
	}

8.3 pci_read_bridge_mmio(), get mem limit
===============================================================================
pci_read_bridge_mmio(struct pci_bus *child)
	struct pci_dev *dev = child->self;

	res = child->resource[1];
	pci_read_config_word(dev, PCI_MEMORY_BASE, &mem_base_lo);
	pci_read_config_word(dev, PCI_MEMORY_LIMIT, &mem_limit_lo);
	base = (mem_base_lo & PCI_MEMORY_RANGE_MASK) << 16;
	limit = (mem_limit_lo & PCI_MEMORY_RANGE_MASK) << 16;
	if (base && base <= limit) {
		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
		region.start = base;
		region.end = limit + 0xfffff;
		pcibios_bus_to_resource(dev, res, &region);
		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
	}

8.3 pci_read_bridge_mmio_pref(), get mem pref limit
===============================================================================

9. pci_assign_unassigned_resources(), go throught the resources and assign them
===============================================================================
pci_assign_unassigned_resources(void)
	struct pci_bus *bus;
	LIST_HEAD(realloc_head); 
	struct list_head *add_list = NULL;
	int tried_times = 0;
	enum release_type rel_type = leaf_only;
	LIST_HEAD(fail_head);
	struct pci_dev_resource *fail_res;
	unsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM |
				  IORESOURCE_PREFETCH;
	int pci_try_num = 1;

	/* don't realloc if asked to do so */
	pci_realloc_detect(); set the pci_realloc_detect variable
	if (pci_realloc_enabled()) {
		; if realloc is enabled, set the pci_try_num 
		; to max_depth + 1
		int max_depth = pci_get_max_depth();

		pci_try_num = max_depth + 1;
		printk(KERN_DEBUG "PCI: max bus depth: %d pci_try_num: %d\n",
			 max_depth, pci_try_num);
	}

again:
	/*
	 * last try will use add_list, otherwise will try good to have as
	 * must have, so can realloc parent bridge resource
	 */
	if (tried_times + 1 == pci_try_num)
		add_list = &realloc_head;

	/* Depth first, calculate sizes and alignments of all
	   subordinate buses. */
	; go through all root bus
	; add_list is the additional resource request
	list_for_each_entry(bus, &pci_root_buses, node)
		__pci_bus_size_bridges(bus, add_list);

	/* Depth last, allocate resources and update the hardware. */
	list_for_each_entry(bus, &pci_root_buses, node)
		__pci_bus_assign_resources(bus, add_list, &fail_head);
	if (add_list)
		BUG_ON(!list_empty(add_list));
	tried_times++;

	/* any device complain? */
	if (list_empty(&fail_head))
		goto enable_and_dump;

	if (tried_times >= pci_try_num) {
		if (pci_realloc_enable == undefined)
			printk(KERN_INFO "Some PCI device resources are unassigned, try booting with pci=realloc\n");
		else if (pci_realloc_enable == auto_enabled)
			printk(KERN_INFO "Automatically enabled pci realloc, if you have problem, try booting with pci=realloc=off\n");

		free_list(&fail_head);
		goto enable_and_dump;
	}

	printk(KERN_DEBUG "PCI: No. %d try to assign unassigned res\n",
			 tried_times + 1);

	/* third times and later will not check if it is leaf */
	if ((tried_times + 1) > 2)
		rel_type = whole_subtree;

	/*
	 * Try to release leaf bridge's resources that doesn't fit resource of
	 * child device under that bridge
	 */
	list_for_each_entry(fail_res, &fail_head, list) {
		bus = fail_res->dev->bus;
		pci_bus_release_bridge_resources(bus,
						 fail_res->flags & type_mask,
						 rel_type);
	}
	/* restore size and flags */
	list_for_each_entry(fail_res, &fail_head, list) {
		struct resource *res = fail_res->res;

		res->start = fail_res->start;
		res->end = fail_res->end;
		res->flags = fail_res->flags;
		if (fail_res->dev->subordinate)
			res->flags = 0;
	}
	free_list(&fail_head);

	goto again;

enable_and_dump:
	/* Depth last, update the hardware. */
	list_for_each_entry(bus, &pci_root_buses, node)
		pci_enable_bridges(bus);

	/* dump the resource on buses */
	list_for_each_entry(bus, &pci_root_buses, node)
		pci_bus_dump_resources(bus);

9.1 __pci_bus_size_bridges(), depth first
===============================================================================
__pci_bus_size_bridges(struct pci_bus *bus, struct list_head *realloc_head)
	struct pci_dev *dev;
	unsigned long mask, prefmask;
	resource_size_t additional_mem_size = 0, additional_io_size = 0;

	; go through all the device of the bus
	list_for_each_entry(dev, &bus->devices, bus_list) {
		struct pci_bus *b = dev->subordinate;
		if (!b)
			continue;

		switch (dev->class >> 8) {
		case PCI_CLASS_BRIDGE_CARDBUS:
			pci_bus_size_cardbus(b, realloc_head);
			break;

		case PCI_CLASS_BRIDGE_PCI:
		default:
			__pci_bus_size_bridges(b, realloc_head);
			break;
		}
	}

	/* The root bus? */
	if (!bus->self)
		return;

	switch (bus->self->class >> 8) {
	case PCI_CLASS_BRIDGE_CARDBUS:
		/* don't size cardbuses yet. */
		break;

	case PCI_CLASS_BRIDGE_PCI:
		pci_bridge_check_ranges(bus);
		if (bus->self->is_hotplug_bridge) {
			; if the bridge support hotplug
			; add additional size
			additional_io_size  = pci_hotplug_io_size;
			additional_mem_size = pci_hotplug_mem_size;
		}
		/*
		 * Follow thru
		 */
	default:
		pbus_size_io(bus, realloc_head ? 0 : additional_io_size,
			     additional_io_size, realloc_head);

		/* If the bridge supports prefetchable range, size it
		   separately. If it doesn't, or its prefetchable window
		   has already been allocated by arch code, try
		   non-prefetchable range for both types of PCI memory
		   resources. */
		mask = IORESOURCE_MEM;
		prefmask = IORESOURCE_MEM | IORESOURCE_PREFETCH;
		if (pbus_size_mem(bus, prefmask, prefmask,
				  realloc_head ? 0 : additional_mem_size,
				  additional_mem_size, realloc_head))
			mask = prefmask; /* Success, size non-prefetch only. */
		else
			additional_mem_size += additional_mem_size;
		pbus_size_mem(bus, mask, IORESOURCE_MEM,
				realloc_head ? 0 : additional_mem_size,
				additional_mem_size, realloc_head);
		break;
	}

9.1.1 pbus_size_io(), if additional resource needed, add it to realloc_head
===============================================================================
pbus_size_io(struct pci_bus *bus, resource_size_t min_size,
		resource_size_t add_size, struct list_head *realloc_head)
	struct pci_dev *dev;
	; b_res point to the corresponding bridge resource
	struct resource *b_res = find_free_bus_resource(bus, IORESOURCE_IO);
	unsigned long size = 0, size0 = 0, size1 = 0;
	resource_size_t children_add_size = 0;

	; no free resource, go
	if (!b_res)
 		return;

	; go through the devices under this bus
	list_for_each_entry(dev, &bus->devices, bus_list) {
		int i;

		for (i = 0; i < PCI_NUM_RESOURCES; i++) {
			struct resource *r = &dev->resource[i];
			unsigned long r_size;

			if (r->parent || !(r->flags & IORESOURCE_IO))
				continue;
			r_size = resource_size(r);

			if (r_size < 0x400)
				/* Might be re-aligned for ISA */
				size += r_size;
			else
				size1 += r_size;

			if (realloc_head); ?
				children_add_size += get_res_add_size(realloc_head, r);
		}
	}
	; calculate size + size1
	size0 = calculate_iosize(size, min_size, size1,
			resource_size(b_res), 4096);
	if (children_add_size > add_size)
		add_size = children_add_size;
	; calculate add_size + size1
	size1 = (!realloc_head || (realloc_head && !add_size)) ? size0 :
		calculate_iosize(size, min_size, add_size + size1,
			resource_size(b_res), 4096);
	if (!size0 && !size1) {
		; io resource is not necessary
		if (b_res->start || b_res->end)
			dev_info(&bus->self->dev, "disabling bridge window "
				 "%pR to [bus %02x-%02x] (unused)\n", b_res,
				 bus->secondary, bus->subordinate);
		b_res->flags = 0;
		return;
	}

	/* Alignment of the IO window is always 4K */
	b_res->start = 4096;
	b_res->end = b_res->start + size0 - 1;
	b_res->flags |= IORESOURCE_STARTALIGN;
	if (size1 > size0 && realloc_head) {
		; size1 > size0 means we need additional resource
		; additional size is size1-size0
		add_to_list(realloc_head, bus->self, b_res, size1-size0, 4096);
		dev_printk(KERN_DEBUG, &bus->self->dev, "bridge window "
				 "%pR to [bus %02x-%02x] add_size %lx\n", b_res,
				 bus->secondary, bus->subordinate, size1-size0);
	}

9.1.1.1 calculate_iosize()
===============================================================================
calculate_iosize(resource_size_t size,
		resource_size_t min_size,
		resource_size_t size1,
		resource_size_t old_size,
		resource_size_t align)
	if (size < min_size)
		size = min_size;
	if (old_size == 1 )
		old_size = 0;
	/* To be fixed in 2.5: we should have sort of HAVE_ISA
	   flag in the struct pci_bus. */
#if defined(CONFIG_ISA) || defined(CONFIG_EISA)
	size = (size & 0xff) + ((size & ~0xffUL) << 2);
#endif
	size = ALIGN(size + size1, align);
	if (size < old_size)
		size = old_size;
	return size;

9.1.2 pbus_size_mem()
===============================================================================
pbus_size_mem(struct pci_bus *bus, unsigned long mask,
			 unsigned long type, resource_size_t min_size,
			resource_size_t add_size,
			struct list_head *realloc_head)
	struct pci_dev *dev;
	resource_size_t min_align, align, size, size0, size1;
	resource_size_t aligns[12];	/* Alignments from 1Mb to 2Gb */
	int order, max_order;
	struct resource *b_res = find_free_bus_resource(bus, type);
	unsigned int mem64_mask = 0;
	resource_size_t children_add_size = 0;

	; no free bus resource
	if (!b_res)
		return 0;

	memset(aligns, 0, sizeof(aligns));
	max_order = 0;
	size = 0;

	mem64_mask = b_res->flags & IORESOURCE_MEM_64;
	b_res->flags &= ~IORESOURCE_MEM_64;

	; go throught the devices under this bus
	; calculate un-allocated resouse size 
	list_for_each_entry(dev, &bus->devices, bus_list) {
		int i;

		for (i = 0; i < PCI_NUM_RESOURCES; i++) {
			struct resource *r = &dev->resource[i];
			resource_size_t r_size;

			; if allocated, type not match, skip
			if (r->parent || (r->flags & mask) != type)
				continue;
			r_size = resource_size(r);
#ifdef CONFIG_PCI_IOV
			/* put SRIOV requested res to the optional list */
			if (realloc_head && i >= PCI_IOV_RESOURCES &&
					i <= PCI_IOV_RESOURCE_END) {
				r->end = r->start - 1;
				add_to_list(realloc_head, dev, r, r_size, 0/* dont' care */);
				children_add_size += r_size;
				continue;
			}
#endif
			/* For bridges size != alignment */
			; get alignment order
			align = pci_resource_alignment(dev, r);
			order = __ffs(align) - 20;
			if (order > 11) {
				dev_warn(&dev->dev, "disabling BAR %d: %pR "
					 "(bad alignment %#llx)\n", i, r,
					 (unsigned long long) align);
				r->flags = 0;
				continue;
			}
			size += r_size;
			if (order < 0)
				order = 0;
			/* Exclude ranges with size > align from
			   calculation of the alignment. */
			if (r_size == align)
				aligns[order] += align;
			if (order > max_order)
				max_order = order;
			mem64_mask &= r->flags & IORESOURCE_MEM_64;

			if (realloc_head) ; for what?
				children_add_size += get_res_add_size(realloc_head, r);
		}
	}
	; calculate the alignment
	align = 0;
	min_align = 0;
	for (order = 0; order <= max_order; order++) {
		resource_size_t align1 = 1;

		align1 <<= (order + 20);

		if (!align)
			min_align = align1;
		else if (ALIGN(align + min_align, min_align) < align1)
			min_align = align1 >> 1;
		align += aligns[order];
	}

	; calculate size 
	size0 = calculate_memsize(size, min_size, 0, resource_size(b_res), min_align);
	if (children_add_size > add_size)
		add_size = children_add_size;
	; calculate size + size1
	size1 = (!realloc_head || (realloc_head && !add_size)) ? size0 :
		calculate_memsize(size, min_size, add_size,
				resource_size(b_res), min_align);

	; sounds no need to have this resource
	if (!size0 && !size1) {
		if (b_res->start || b_res->end)
			dev_info(&bus->self->dev, "disabling bridge window "
				 "%pR to [bus %02x-%02x] (unused)\n", b_res,
				 bus->secondary, bus->subordinate);
		b_res->flags = 0;
		return 1;
	}

	b_res->start = min_align;
	b_res->end = size0 + min_align - 1;
	b_res->flags |= IORESOURCE_STARTALIGN | mem64_mask;
	if (size1 > size0 && realloc_head) {
		; add the additional resource request (size1-size0) to list
		add_to_list(realloc_head, bus->self, b_res, size1-size0, min_align);
		dev_printk(KERN_DEBUG, &bus->self->dev, "bridge window "
				 "%pR to [bus %02x-%02x] add_size %llx\n", b_res,
				 bus->secondary, bus->subordinate, (unsigned long long)size1-size0);
	}
	return 1;

9.1.2.1 calculate_memsize()
===============================================================================
calculate_memsize(resource_size_t size,
		resource_size_t min_size,
		resource_size_t size1,
		resource_size_t old_size,
		resource_size_t align)
	if (size < min_size)
		size = min_size;
	if (old_size == 1 )
		old_size = 0;
	if (size < old_size)
		size = old_size;
	size = ALIGN(size + size1, align);
	return size;

9.2 __pci_bus_assign_resources(), allocate the resoueces with realloc_head contain the additional resource 
===============================================================================
__pci_bus_assign_resources(const struct pci_bus *bus,
					 struct list_head *realloc_head,
					 struct list_head *fail_head)
; realloc_head contains the list of resource which want additional resource
	struct pci_bus *b;
	struct pci_dev *dev;

	pbus_assign_resources_sorted(bus, realloc_head, fail_head);

	list_for_each_entry(dev, &bus->devices, bus_list) {
		b = dev->subordinate;
		if (!b)
			continue;

		__pci_bus_assign_resources(b, realloc_head, fail_head);

		switch (dev->class >> 8) {
		case PCI_CLASS_BRIDGE_PCI:
			if (!pci_is_enabled(dev))
				pci_setup_bridge(b);
			break;

		case PCI_CLASS_BRIDGE_CARDBUS:
			pci_setup_cardbus(b);
			break;

		default:
			dev_info(&dev->dev, "not setting up bridge for bus "
				 "%04x:%02x\n", pci_domain_nr(b), b->number);
			break;
		}
	}

9.2.1 pbus_assign_resources_sorted()
===============================================================================
pbus_assign_resources_sorted(const struct pci_bus *bus,
					 struct list_head *realloc_head,
					 struct list_head *fail_head)
	struct pci_dev *dev;
	LIST_HEAD(head);

	list_for_each_entry(dev, &bus->devices, bus_list)
		__dev_sort_resources(dev, &head);

	; now we get the unallocated resource in *head*,
	; which contains all the requirement under this bus
	; realloc_head contains the additional requirement
	__assign_resources_sorted(&head, realloc_head, fail_head);


9.2.1.1 __dev_sort_resources(), unallocated resource is add to head
===============================================================================
__dev_sort_resources(struct pci_dev *dev,
				 struct list_head *head)
	u16 class = dev->class >> 8;

	/* Don't touch classless devices or host bridges or ioapics.  */
	if (class == PCI_CLASS_NOT_DEFINED || class == PCI_CLASS_BRIDGE_HOST)
		return;

	/* Don't touch ioapic devices already enabled by firmware */
	if (class == PCI_CLASS_SYSTEM_PIC) {
		u16 command;
		pci_read_config_word(dev, PCI_COMMAND, &command);
		if (command & (PCI_COMMAND_IO | PCI_COMMAND_MEMORY))
			return;
	}

	; add the unallocated resource to list *head*
	pdev_sort_resources(dev, head);

9.2.1.1.1 pdev_sort_resources(), go through the dev resources, add relevant to head, in decrease order
===============================================================================
pdev_sort_resources(struct pci_dev *dev, struct list_head *head)
	int i;

	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
		struct resource *r;
		struct pci_dev_resource *dev_res, *tmp;
		resource_size_t r_align;
		struct list_head *n;

		r = &dev->resource[i];

		if (r->flags & IORESOURCE_PCI_FIXED)
			continue;

		; disabled, or already allocated 
		if (!(r->flags) || r->parent)
			continue;

		r_align = pci_resource_alignment(dev, r);
		if (!r_align) {
			dev_warn(&dev->dev, "BAR %d: %pR has bogus alignment\n",
				 i, r);
			continue;
		}

		tmp = kzalloc(sizeof(*tmp), GFP_KERNEL);
		if (!tmp)
			panic("pdev_sort_resources(): "
			      "kmalloc() failed!\n");
		tmp->res = r;
		tmp->dev = dev;

		/* fallback is smallest one or list is empty*/
		n = head;
		list_for_each_entry(dev_res, head, list) {
			resource_size_t align;

			align = pci_resource_alignment(dev_res->dev,
							 dev_res->res);

			if (r_align > align) {
				n = &dev_res->list;
				break;
			}
		}
		/* Insert it just before n*/
		list_add_tail(&tmp->list, n);
	}

9.2.1.2 __assign_resources_sorted()
===============================================================================
; head is a list of resources where is required?
; realloc_head is the additional resource
__assign_resources_sorted(struct list_head *head,
				 struct list_head *realloc_head,
				 struct list_head *fail_head)
	/*
	 * Should not assign requested resources at first.
	 *   they could be adjacent, so later reassign can not reallocate
	 *   them one by one in parent resource window.
	 * Try to assign requested + add_size at begining
	 *  if could do that, could get out early.
	 *  if could not do that, we still try to assign requested at first,
	 *    then try to reassign add_size for some resources.
	 */
	LIST_HEAD(save_head);
	LIST_HEAD(local_fail_head);
	struct pci_dev_resource *save_res;
	struct pci_dev_resource *dev_res;

	/* Check if optional add_size is there */
	; no additional request, jump to the end
	if (!realloc_head || list_empty(realloc_head))
		goto requested_and_reassign;

	/* Save original start, end, flags etc at first */
	; one copy 
	list_for_each_entry(dev_res, head, list) {
		if (add_to_list(&save_head, dev_res->dev, dev_res->res, 0, 0)) {
			free_list(&save_head);
			goto requested_and_reassign;
		}
	}

	/* Update res in head list with add_size in realloc_head list */
	; confused
	list_for_each_entry(dev_res, head, list)
		dev_res->res->end += get_res_add_size(realloc_head,
							dev_res->res);

	/* Try updated head list with add_size added */
	assign_requested_resources_sorted(head, &local_fail_head);

	/* all assigned with add_size ? */
	if (list_empty(&local_fail_head)) {
		; everything is perfect
		; return
		/* Remove head list from realloc_head list */
		list_for_each_entry(dev_res, head, list)
			remove_from_list(realloc_head, dev_res->res);
		free_list(&save_head);
		free_list(head);
		return;
	}

	free_list(&local_fail_head);
	/* Release assigned resource */
	;release it?
	list_for_each_entry(dev_res, head, list)
		if (dev_res->res->parent)
			release_resource(dev_res->res);

	/* Restore start/end/flags from saved list */
	list_for_each_entry(save_res, &save_head, list) {
		struct resource *res = save_res->res;

		res->start = save_res->start;
		res->end = save_res->end;
		res->flags = save_res->flags;
	}
	free_list(&save_head);

requested_and_reassign:
	/* Satisfy the must-have resource requests */
	; ok, head contains the must-have request
	; real work?
	assign_requested_resources_sorted(head, fail_head);

	/* Try to satisfy any additional optional resource requests */
	; realloc_head contains the additional request
	if (realloc_head)
		reassign_resources_sorted(realloc_head, head);
	free_list(head);

9.2.1.2.1 assign_requested_resources_sorted()
===============================================================================
assign_requested_resources_sorted(struct list_head *head,
				 struct list_head *fail_head)
	struct resource *res;
	struct pci_dev_resource *dev_res;
	int idx;

	; go through the head list
	list_for_each_entry(dev_res, head, list) {
		res = dev_res->res;
		idx = res - &dev_res->dev->resource[0];
		if (resource_size(res) &&
		    pci_assign_resource(dev_res->dev, idx)) {
			if (fail_head && !pci_is_root_bus(dev_res->dev->bus)) {
				/*
				 * if the failed res is for ROM BAR, and it will
				 * be enabled later, don't add it to the list
				 */
				if (!((idx == PCI_ROM_RESOURCE) &&
				      (!(res->flags & IORESOURCE_ROM_ENABLE))))
					add_to_list(fail_head,
						    dev_res->dev, res,
						    0 /* dont care */,
						    0 /* dont care */);
			}
			reset_resource(res);
		}
	}

9.2.1.2.2 reassign_resource_sorted(), satisfy any additional resource requests
===============================================================================
; realloc_head a list of additional request
; head a list of 
reassign_resources_sorted(struct list_head *realloc_head,
		struct list_head *head)
	struct resource *res;
	struct pci_dev_resource *add_res, *tmp;
	struct pci_dev_resource *dev_res;
	resource_size_t add_size;
	int idx;

	; go throught the realloc_head list
	; each one represent additional resource request
	list_for_each_entry_safe(add_res, tmp, realloc_head, list) {
		bool found_match = false;

		res = add_res->res;
		/* skip resource that has been reset */
		if (!res->flags)
			goto out;

		/* skip this resource if not found in head list */
		list_for_each_entry(dev_res, head, list) {
			if (dev_res->res == res) {
				found_match = true;
				break;
			}
		}
		; if not found in head, skip
		if (!found_match)/* just skip */
			continue;

		idx = res - &add_res->dev->resource[0];
		add_size = add_res->add_size;
		if (!resource_size(res)) {
			res->start = add_res->start;
			res->end = res->start + add_size - 1;
			if (pci_assign_resource(add_res->dev, idx))
				reset_resource(res);
		} else {
			resource_size_t align = add_res->min_align;
			res->flags |= add_res->flags &
				 (IORESOURCE_STARTALIGN|IORESOURCE_SIZEALIGN);
			if (pci_reassign_resource(add_res->dev, idx,
						  add_size, align))
				dev_printk(KERN_DEBUG, &add_res->dev->dev,
					   "failed to add %llx res[%d]=%pR\n",
					   (unsigned long long)add_size,
					   idx, res);
		}
out:
		list_del(&add_res->list);
		kfree(add_res);
	}

10. pci_assign_resource()
===============================================================================
pci_assign_resource(struct pci_dev *dev, int resno)
	struct resource *res = dev->resource + resno;
	resource_size_t align, size;
	struct pci_bus *bus;
	int ret;

	align = pci_resource_alignment(dev, res);
	if (!align) {
		dev_info(&dev->dev, "BAR %d: can't assign %pR "
			 "(bogus alignment)\n", resno, res);
		return -EINVAL;
	}

	bus = dev->bus;
	size = resource_size(res);
	ret = _pci_assign_resource(dev, resno, size, align);

	/*
	 * If we failed to assign anything, let's try the address
	 * where firmware left it.  That at least has a chance of
	 * working, which is better than just leaving it disabled.
	 */
	if (ret < 0)
		ret = pci_revert_fw_address(res, dev, resno, size);

	if (!ret) {
		res->flags &= ~IORESOURCE_STARTALIGN;
		dev_info(&dev->dev, "BAR %d: assigned %pR\n", resno, res);
		; update to hardware
		if (resno < PCI_BRIDGE_RESOURCES)
			pci_update_resource(dev, resno);
	}
	return ret;

10.1 _pci_assign_resource()
===============================================================================
_pci_assign_resource(struct pci_dev *dev, int resno, int size, resource_size_t min_align)
	struct resource *res = dev->resource + resno;
	struct pci_bus *bus;
	int ret;
	char *type;

	bus = dev->bus;
	; try to assign from its parent
	while ((ret = __pci_assign_resource(bus, dev, resno, size, min_align))) {
		if (!bus->parent || !bus->self->transparent)
			break;
		bus = bus->parent;
	}

	if (ret) {
		if (res->flags & IORESOURCE_MEM)
			if (res->flags & IORESOURCE_PREFETCH)
				type = "mem pref";
			else
				type = "mem";
		else if (res->flags & IORESOURCE_IO)
			type = "io";
		else
			type = "unknown";
		dev_info(&dev->dev,
			 "BAR %d: can't assign %s (size %#llx)\n",
			 resno, type, (unsigned long long) resource_size(res));
	}

	return ret;

10.1.1 __pci_assign_resource()
===============================================================================
__pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
		int resno, resource_size_t size, resource_size_t align)
	struct resource *res = dev->resource + resno;
	resource_size_t min;
	int ret;

	; the lower bondery is set according to its type
	min = (res->flags & IORESOURCE_IO) ? PCIBIOS_MIN_IO : PCIBIOS_MIN_MEM;

	/* First, try exact prefetching match.. */
	ret = pci_bus_alloc_resource(bus, res, size, align, min,
				     IORESOURCE_PREFETCH,
				     pcibios_align_resource, dev);

	if (ret < 0 && (res->flags & IORESOURCE_PREFETCH)) {
		/*
		 * That failed.
		 *
		 * But a prefetching area can handle a non-prefetching
		 * window (it will just not perform as well).
		 */
		ret = pci_bus_alloc_resource(bus, res, size, align, min, 0,
					     pcibios_align_resource, dev);
	}
	return ret;

10.1.1.1 pci_bus_alloc_resource()
===============================================================================
pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
		resource_size_t size, resource_size_t align,
		resource_size_t min, unsigned int type_mask,
		resource_size_t (*alignf)(void *,
					  const struct resource *,
					  resource_size_t,
					  resource_size_t),
		void *alignf_data)
	int i, ret = -ENOMEM;
	struct resource *r;
	resource_size_t max = -1;

	type_mask |= IORESOURCE_IO | IORESOURCE_MEM;

	/* don't allocate too high if the pref mem doesn't support 64bit*/
	if (!(res->flags & IORESOURCE_MEM_64))
		max = PCIBIOS_MAX_MEM_32;

	; go throught the bus's resource and find which one matches
	pci_bus_for_each_resource(bus, r, i) {
		if (!r)
			continue;

		/* type_mask must match */
		if ((res->flags ^ r->flags) & type_mask)
			continue;

		/* We cannot allocate a non-prefetching resource
		   from a pre-fetching area */
		if ((r->flags & IORESOURCE_PREFETCH) &&
		    !(res->flags & IORESOURCE_PREFETCH))
			continue;

		/* Ok, try it out.. */
		ret = allocate_resource(r, res, size,
					r->start ? : min,
					max, align,
					alignf, alignf_data);
		if (ret == 0)
			break;
	}
	return ret;
 
11. pci_reassign_resource()
===============================================================================
pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsize,
			resource_size_t min_align)
	struct resource *res = dev->resource + resno;
	resource_size_t new_size;
	int ret;

	if (!res->parent) {
		dev_info(&dev->dev, "BAR %d: can't reassign an unassigned resource %pR "
			 "\n", resno, res);
		return -EINVAL;
	}

	/* already aligned with min_align */
	new_size = resource_size(res) + addsize;
	ret = _pci_assign_resource(dev, resno, new_size, min_align);
	if (!ret) {
		res->flags &= ~IORESOURCE_STARTALIGN;
		dev_info(&dev->dev, "BAR %d: reassigned %pR\n", resno, res);
		if (resno < PCI_BRIDGE_RESOURCES)
			pci_update_resource(dev, resno);
	}
	return ret;

12. pci_enable_sriov(), enable the sriov for the PF
===============================================================================
; this function is called in the driver to generate the VFs
pci_enable_sriov(struct pci_dev *dev, int nr_virtfn)
	might_sleep();

	if (!dev->is_physfn)
		return -ENODEV;

	return sriov_enable(dev, nr_virtfn);

12.1 sriov_enable()
===============================================================================
sriov_enable(struct pci_dev *dev, int nr_virtfn)
	int rc;
	int i, j;
	int nres;
	u16 offset, stride, initial;
	struct resource *res;
	struct pci_dev *pdev;
	struct pci_sriov *iov = dev->sriov;
	int bars = 0;

	; validate the parameters
	if (!nr_virtfn)
		return 0;

	if (iov->nr_virtfn)
		return -EINVAL;

	pci_read_config_word(dev, iov->pos + PCI_SRIOV_INITIAL_VF, &initial);
	if (initial > iov->total ||
	    (!(iov->cap & PCI_SRIOV_CAP_VFM) && (initial != iov->total)))
		return -EIO;

	if (nr_virtfn < 0 || nr_virtfn > iov->total ||
	    (!(iov->cap & PCI_SRIOV_CAP_VFM) && (nr_virtfn > initial)))
		return -EINVAL;

	pci_write_config_word(dev, iov->pos + PCI_SRIOV_NUM_VF, nr_virtfn);
	; retrieve the offset and stride
	pci_read_config_word(dev, iov->pos + PCI_SRIOV_VF_OFFSET, &offset);
	pci_read_config_word(dev, iov->pos + PCI_SRIOV_VF_STRIDE, &stride);
	if (!offset || (nr_virtfn > 1 && !stride))
		return -EIO;

	nres = 0;
	for (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {
		bars |= (1 << (i + PCI_IOV_RESOURCES));
		res = dev->resource + PCI_IOV_RESOURCES + i;
		if (res->parent)
			nres++;
	}
	if (nres != iov->nres) {
		dev_err(&dev->dev, "not enough MMIO resources for SR-IOV\n");
		return -ENOMEM;
	}

	iov->offset = offset;
	iov->stride = stride;

	; check the virtual bus number
	if (virtfn_bus(dev, nr_virtfn - 1) > dev->bus->subordinate) {
		dev_err(&dev->dev, "SR-IOV: bus number out of range\n");
		return -ENOMEM;
	}

	if (pci_enable_resources(dev, bars)) {
		dev_err(&dev->dev, "SR-IOV: IOV BARS not allocated\n");
		return -ENOMEM;
	}

	if (iov->link != dev->devfn) {
		pdev = pci_get_slot(dev->bus, iov->link);
		if (!pdev)
			return -ENODEV;

		pci_dev_put(pdev);

		if (!pdev->is_physfn)
			return -ENODEV;

		rc = sysfs_create_link(&dev->dev.kobj,
					&pdev->dev.kobj, "dep_link");
		if (rc)
			return rc;
	}

	; enable the VF
	iov->ctrl |= PCI_SRIOV_CTRL_VFE | PCI_SRIOV_CTRL_MSE;
	pci_cfg_access_lock(dev);
	pci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, iov->ctrl);
	msleep(100);
	pci_cfg_access_unlock(dev);

	iov->initial = initial;
	if (nr_virtfn < initial)
		initial = nr_virtfn;

	for (i = 0; i < initial; i++) {
		rc = virtfn_add(dev, i, 0);
		if (rc)
			goto failed;
	}

	if (iov->cap & PCI_SRIOV_CAP_VFM) {
		rc = sriov_enable_migration(dev, nr_virtfn);
		if (rc)
			goto failed;
	}

	kobject_uevent(&dev->dev.kobj, KOBJ_CHANGE);
	iov->nr_virtfn = nr_virtfn;

	return 0;

failed:
	for (j = 0; j < i; j++)
		virtfn_remove(dev, j, 0);

	iov->ctrl &= ~(PCI_SRIOV_CTRL_VFE | PCI_SRIOV_CTRL_MSE);
	pci_cfg_access_lock(dev);
	pci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, iov->ctrl);
	ssleep(1);
	pci_cfg_access_unlock(dev);

	if (iov->link != dev->devfn)
		sysfs_remove_link(&dev->dev.kobj, "dep_link");

	return rc;

12.1.1 virtfn_add()
===============================================================================
; id starts from 0
virtfn_add(struct pci_dev *dev, int id, int reset)
	int i;
	int rc;
	u64 size;
	char buf[VIRTFN_ID_LEN];
	struct pci_dev *virtfn;
	struct resource *res;
	struct pci_sriov *iov = dev->sriov;

	virtfn = alloc_pci_dev();
	if (!virtfn)
		return -ENOMEM;

	; create the virtual pci_bus
	mutex_lock(&iov->dev->sriov->lock);
	virtfn->bus = virtfn_add_bus(dev->bus, virtfn_bus(dev, id));
	if (!virtfn->bus) {
		kfree(virtfn);
		mutex_unlock(&iov->dev->sriov->lock);
		return -ENOMEM;
	}
	virtfn->devfn = virtfn_devfn(dev, id);
	virtfn->vendor = dev->vendor;
	pci_read_config_word(dev, iov->pos + PCI_SRIOV_VF_DID, &virtfn->device);
	
	; set up the virtual pci_dev
	pci_setup_device(virtfn);
	virtfn->dev.parent = dev->dev.parent;

	; allocate the resources
	for (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {
		res = dev->resource + PCI_IOV_RESOURCES + i;
		if (!res->parent)
			continue;
		virtfn->resource[i].name = pci_name(virtfn);
		virtfn->resource[i].flags = res->flags;
		size = resource_size(res);
		do_div(size, iov->total);
		virtfn->resource[i].start = res->start + size * id;
		virtfn->resource[i].end = virtfn->resource[i].start + size - 1;
		rc = request_resource(res, &virtfn->resource[i]);
		BUG_ON(rc);
	}

	if (reset)
		__pci_reset_function(virtfn);

	pci_device_add(virtfn, virtfn->bus);
	mutex_unlock(&iov->dev->sriov->lock);

	virtfn->physfn = pci_dev_get(dev);
	virtfn->is_virtfn = 1;

	rc = pci_bus_add_device(virtfn);
	if (rc)
		goto failed1;
	sprintf(buf, "virtfn%u", id);
	rc = sysfs_create_link(&dev->dev.kobj, &virtfn->dev.kobj, buf);
	if (rc)
		goto failed1;
	rc = sysfs_create_link(&virtfn->dev.kobj, &dev->dev.kobj, "physfn");
	if (rc)
		goto failed2;

	kobject_uevent(&virtfn->dev.kobj, KOBJ_CHANGE);

	return 0;

failed2:
	sysfs_remove_link(&dev->dev.kobj, buf);
failed1:
	pci_dev_put(dev);
	mutex_lock(&iov->dev->sriov->lock);
	pci_stop_and_remove_bus_device(virtfn);
	virtfn_remove_bus(dev->bus, virtfn_bus(dev, id));
	mutex_unlock(&iov->dev->sriov->lock);

	return rc;


               struct pci_dev
               +------------------------------------+
               |dev(struct device)                  |
               |   parent           ----------------|----+ 
               |   bus = &pci_bus_type              |    |
               +------------------------------------+    |
               |bus(pci_bus) attached to which bus  |    |
               |    bridge(device)                  |<---+ 
               +------------------------------------+    |
               |devfn (device/function number)      |    | 
               |vendor (vendor ID)                  |    | 
               |device (device ID)                  |    | 
               +------------------------------------+    |
               |resource                            |    |
               |    (an array of struct resource)   |    |
               |    retrieve addreess from BAR      |    |
               |                                    |    |
               |                                    |    |
               +------------------------------------+    |
                                                         |
               virtual pci_dev                           |
               +------------------------------------+    |
               |dev(struct device)                  |    |
               |   parent           ----------------|----+ 
               |   bus = &pci_bus_type              |     
               +------------------------------------+     
               |bus(pci_bus) attached to which bus  |     
               |    bridge(device)                  |      
               +------------------------------------+
               |devfn (device/function number)      |      
               |vendor  same as PF's                |      
               |device (device ID)                  |      
               +------------------------------------+
               |resource                            |
               |    use the first 6                 |
               |                                    |
               +------------------------------------+

               Figure 12.1 vitual pci_dev and physical pci_dev

12.1.1.1 virtfn_add_bus(), create the virtual bus for VF
===============================================================================
pci_bus *virtfn_add_bus(struct pci_bus *bus, int busnr)
	int rc;
	struct pci_bus *child;

	if (bus->number == busnr)
		return bus;

	child = pci_find_bus(pci_domain_nr(bus), busnr);
	if (child)
		return child;

	child = pci_add_new_bus(bus, NULL, busnr);
	if (!child)
		return NULL;

	child->subordinate = busnr;
	child->dev.parent = bus->bridge;
	rc = pci_bus_add_child(child);
	if (rc) {
		pci_remove_bus(child);
		return NULL;
	}

	return child;

             -------+---------      Bus 00(pci_bus) <-------------------+
                    |                 +---secondary(00) <---------------|------+
        +-----------+--------+                                          |      |
        |     00:02.0        |P2P bridge(pci_dev)                       |      |
        | PCIe-PCI bridge    |<--------------------------------------------+   |
        +--------------------+                                          |  |   |
        |dev(device)         |<----------------------------------------------+ |
        +---------------------                                          |  | | |
        |subordinate(pci_bus)|----------+                               |  | | |
        +-----------+--------+          |                               |  | | |
                    |                   +------->+--------------------+ |  | | |
                    |                            |parent              |-+  | | |
         +---------------------+  Bus 02(pci_bus)+--------------------+    | | |
         |                     |                 |self(pci_dev)       |----+ | |
     +----v----+           +----v----+           +--------------------+      | |
     | 02:00.0 |           | 02:01.0 |           |bridge(device)      |------+ |                              
     |(pci_dev)|           |(pci_dev)| +----->   +--------------------+        |                              
     +---------+           +---------+ |         |primary             |--------+                              
                                       |         +--------------------+                                       
                                       |         |resource(struct *)  |            
                                       |         |  point to bridge   |
                                       |         +--------------------+
                                       |         |children(list_head) |
                                       |         +---------+----------+
      Virtual Bus 08(pci_bus)          |            ---+---+---+---
      +-------------------+<-----------|---------------+       +---
      |parent             |------------+                
      +-------------------+ 
      |primary            |set to parent.secondary
      |number             | -+
      |                   |  | these two are 
      |subordinate        | -+ the same
      +-------------------+
      |self = NULL        |
      |bridge = NULL      |
      +-------------------+
      |resource[] = NULL  |
      +-------------------+
      |dev.parent         |set to parent.bridge?
      +-------------------+




                     Figure 12.2 virtual bus and physical bus
                     (this is an example, the number could be different)

12.1.2 virtfn_bus(), calculate the bus number for VF
===============================================================================
virtfn_bus(struct pci_dev *dev, int id)
	return dev->bus->number + ((dev->devfn + dev->sriov->offset +
				    dev->sriov->stride * id) >> 8);

13. pci_enable_resources()
===============================================================================
pci_enable_resources(struct pci_dev *dev, int mask)
	u16 cmd, old_cmd;
	int i;
	struct resource *r;

	pci_read_config_word(dev, PCI_COMMAND, &cmd);
	old_cmd = cmd;

	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
		if (!(mask & (1 << i)))
			continue;

		r = &dev->resource[i];

		if (!(r->flags & (IORESOURCE_IO | IORESOURCE_MEM)))
			continue;
		if ((i == PCI_ROM_RESOURCE) &&
				(!(r->flags & IORESOURCE_ROM_ENABLE)))
			continue;

		if (!r->parent) {
			dev_err(&dev->dev, "device not available "
				"(can't reserve %pR)\n", r);
			return -EINVAL;
		}

		if (r->flags & IORESOURCE_IO)
			cmd |= PCI_COMMAND_IO;
		if (r->flags & IORESOURCE_MEM)
			cmd |= PCI_COMMAND_MEMORY;
	}

	if (cmd != old_cmd) {
		dev_info(&dev->dev, "enabling device (%04x -> %04x)\n",
			 old_cmd, cmd);
		pci_write_config_word(dev, PCI_COMMAND, cmd);
	}
	return 0;

14. pci_enable_msi(), called in driver to enable msi
===============================================================================
#define pci_enable_msi(pdev)	pci_enable_msi_block(pdev, 1)
pci_enable_msi_block(struct pci_dev *dev, unsigned int nvec)
	int status, pos, maxvec;
	u16 msgctl;

	pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
	if (!pos)
		return -EINVAL;
	pci_read_config_word(dev, pos + PCI_MSI_FLAGS, &msgctl);
	; maxvec is the available msi number in hardware
	maxvec = 1 << ((msgctl & PCI_MSI_FLAGS_QMASK) >> 1);
	if (nvec > maxvec)
		return maxvec;

	status = pci_msi_check_device(dev, nvec, PCI_CAP_ID_MSI);
	if (status)
		return status;

	WARN_ON(!!dev->msi_enabled);

	/* Check whether driver already requested MSI-X irqs */
	if (dev->msix_enabled) {
		dev_info(&dev->dev, "can't enable MSI "
			 "(MSI-X already enabled)\n");
		return -EINVAL;
	}

	status = msi_capability_init(dev, nvec);
	return status;

14.1 pci_msi_check_device()
===============================================================================
pci_msi_check_device(struct pci_dev *dev, int nvec, int type)
	struct pci_bus *bus;
	int ret;

	/* MSI must be globally enabled and supported by the device */
	if (!pci_msi_enable || !dev || dev->no_msi)
		return -EINVAL;

	/*
	 * You can't ask to have 0 or less MSIs configured.
	 *  a) it's stupid ..
	 *  b) the list manipulation code assumes nvec >= 1.
	 */
	if (nvec < 1)
		return -ERANGE;

	/*
	 * Any bridge which does NOT route MSI transactions from its
	 * secondary bus to its primary bus must set NO_MSI flag on
	 * the secondary pci_bus.
	 * We expect only arch-specific PCI host bus controller driver
	 * or quirks for specific PCI bridges to be setting NO_MSI.
	 */
	for (bus = dev->bus; bus; bus = bus->parent)
		if (bus->bus_flags & PCI_BUS_FLAGS_NO_MSI)
			return -EINVAL;

	ret = arch_msi_check_device(dev, nvec, type);
	if (ret)
		return ret;

	if (!pci_find_capability(dev, type))
		return -EINVAL;

	return 0;

14.2 msi_capability_init()
===============================================================================
msi_capability_init(struct pci_dev *dev, int nvec)
	struct msi_desc *entry;
	int pos, ret;
	u16 control;
	unsigned mask;

	pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
	msi_set_enable(dev, pos, 0);	/* Disable MSI during set up */

	pci_read_config_word(dev, msi_control_reg(pos), &control);
	/* MSI Entry Initialization */
	entry = alloc_msi_entry(dev);
	if (!entry)
		return -ENOMEM;

	entry->msi_attrib.is_msix	= 0;
	entry->msi_attrib.is_64		= is_64bit_address(control);
	entry->msi_attrib.entry_nr	= 0;
	entry->msi_attrib.maskbit	= is_mask_bit_support(control);
	entry->msi_attrib.default_irq	= dev->irq;	/* Save IOAPIC IRQ */
	entry->msi_attrib.pos		= pos;

	entry->mask_pos = msi_mask_reg(pos, entry->msi_attrib.is_64);
	/* All MSIs are unmasked by default, Mask them all */
	if (entry->msi_attrib.maskbit)
		pci_read_config_dword(dev, entry->mask_pos, &entry->masked);
	mask = msi_capable_mask(control);
	msi_mask_irq(entry, mask, mask);

	list_add_tail(&entry->list, &dev->msi_list);

	/* Configure MSI capability structure */
	ret = arch_setup_msi_irqs(dev, nvec, PCI_CAP_ID_MSI);
	if (ret) {
		msi_mask_irq(entry, mask, ~mask);
		free_msi_irqs(dev);
		return ret;
	}

	ret = populate_msi_sysfs(dev);
	if (ret) {
		msi_mask_irq(entry, mask, ~mask);
		free_msi_irqs(dev);
		return ret;
	}

	/* Set MSI enabled bits	 */
	pci_intx_for_msi(dev, 0);
	msi_set_enable(dev, pos, 1);
	dev->msi_enabled = 1;

	dev->irq = entry->irq;
	return 0;
}

15. understand the lspci output
===============================================================================

15.1. show the numberic output
===============================================================================
$ lspci -n | head -n 5
0000:00:00.0 0604: 1014:03b9 (rev 10)
0000:01:00.0 0604: 111d:8018 (rev 0e)
0000:02:02.0 0604: 111d:8018 (rev 0e)
0000:02:04.0 0604: 111d:8018 (rev 0e)
0000:20:00.0 0200: 8086:10bc (rev 06)

domain:b:d:f device class: vendor ID: device ID

15.2. convert lspci output to physical layout
===============================================================================
$ lspci -t
-+-[0005:00]---00.0-[01-a0]----00.0-[02-a0]--+-04.0-[20]--
 |                                           +-05.0-[40]--
 |                                           +-06.0-[60]----00.0
 |                                           +-08.0-[80-90]----00.0-[90]--+-01.0
 |                                           |                            +-01.1
 |                                           |                            \-01.2
 |                                           \-09.0-[a0]--
 +-[0004:00]---00.0-[01]--
 +-[0003:00]---00.0-[01]--
 +-[0002:00]---00.0-[01]--
 +-[0001:00]---00.0-[01]--
 \-[0000:00]---00.0-[01-40]----00.0-[02-40]--+-02.0-[20]--+-00.0
                                             |            \-00.1
                                             \-04.0-[40]--+-00.0
                                                          \-00.1

number in the square of a device means the bus number range of the bridge.

$ lspci | grep 0005
0005:00:00.0 PCI bridge: IBM Device 03b9 (rev 10)
0005:01:00.0 PCI bridge: PLX Technology, Inc. PEX 8624 24-lane, 6-Port PCI Express Gen 2 (5.0 GT/s) Switch [ExpressLane] (rev bb)
0005:02:04.0 PCI bridge: PLX Technology, Inc. PEX 8624 24-lane, 6-Port PCI Express Gen 2 (5.0 GT/s) Switch [ExpressLane] (rev bb)
0005:02:05.0 PCI bridge: PLX Technology, Inc. PEX 8624 24-lane, 6-Port PCI Express Gen 2 (5.0 GT/s) Switch [ExpressLane] (rev bb)
0005:02:06.0 PCI bridge: PLX Technology, Inc. PEX 8624 24-lane, 6-Port PCI Express Gen 2 (5.0 GT/s) Switch [ExpressLane] (rev bb)
0005:02:08.0 PCI bridge: PLX Technology, Inc. PEX 8624 24-lane, 6-Port PCI Express Gen 2 (5.0 GT/s) Switch [ExpressLane] (rev bb)
0005:02:09.0 PCI bridge: PLX Technology, Inc. PEX 8624 24-lane, 6-Port PCI Express Gen 2 (5.0 GT/s) Switch [ExpressLane] (rev bb)
0005:60:00.0 RAID bus controller: IBM Obsidian-E PCI-E SCSI controller (rev 01)
0005:80:00.0 PCI bridge: PLX Technology, Inc. PEX8112 x1 Lane PCI Express-to-PCI Bridge (rev aa)
0005:90:01.0 USB Controller: NEC Corporation USB (rev 43)
0005:90:01.1 USB Controller: NEC Corporation USB (rev 43)
0005:90:01.2 USB Controller: NEC Corporation USB 2.0 (rev 04)




                                     --------+---------- Bus #0
                                             |          
                                   +---------+----------+
                                   |IBM Device 00:00.0  |
                                   |           [01-a0]  |
                                   +---------+----------+
                                             |           
                              ---------------+-----------------Bus #1
  Physical Bridge                            |          
  +----------------------------------------------------------------------------------------------------------------+
  |                                          |                                 Internal representation             |
  |                                +---------+----------+                                                          |
  |                                |PLX Bridge 01:00.0  |                                                          |
  |                                |           [02-a0]  |                                                          |
  |                                +---------+----------+                                                          |
  |                                          |                                                                     |
  |   -----+---------------------+-----------+-------+------------------+---------------+-Bus #2                   |
  |        |                     |                   |                  |               |                          |
  | +------+-------+    +--------+------+      +-----+-------+  +-------+----------+  +-+---------------+          |
  | |PLX Bridge    |    |PLX Bridge     |      |PLX Bridge   |  |PLX Bridge        |  |PLX Bridge       |          |
  | |02:04.0       |    |02:05.0        |      |02:06.0      |  |02:08.0 [80-90]   |  |02:09.0          |          |
  | +------+-------+    +-----+---------+      +----+--------+  +-------+----------+  +-------+---------+          |
  |        |                  |                     |                   |                     |                    |
  +----------------------------------------------------------------------------------------------------------------+
           |                  |                     |                   |                     |                     
       ----+-----Bus#20    ---+----Bus#40        ---+-----Bus#60    ----+------Bus#80 --------+---------Bus#a0      
                                                                        |                                           
                                                                +-------+-----------+                         
                                                                |PLX Bridge 80:00.0 |                         
                                                                |                   |                         
                                                                +-------+-----------+                         
                                                                        |                                     
                                                      -------+----------++---------------+---------Bus#90
                                                             |           |               |               
                                                      +------+------+  +-+---------+  +--+----------+    
                                                      |usb 90:01.0  |  |usb 90:01.1|  |usb 90:01.2  |    
                                                      +-------------+  +-----------+  +-------------+    

0. Figures, internal representation of pci subsystem
===============================================================================
                    
                                   -------+---------Bus 00(pci_bus) 
                                          |                 
                                 +--------+--------+       
                                 |     00:02.0     |      
                                 | PCIe-PCI bridge |
                                 | (pci_dev)       |
                                 +--------+--------+
                                          |                                
                                          |                                
                               +---------------------+    Bus 02(pci_bus)  
                               |                     |                     
                               |                     |                     
                               |                     |                     
                          +----v----+           +----v----+                
                          | 02:00.0 |           | 02:01.0 |                
                          |(pci_dev)|           |(pci_dev)|                
                          +---------+           +---------+

                     Figure 0.1 internal representaion of PCIe/PCE bridge
                                and its child bus and devices
                     (this is an example, the number could be different)
         

                                      ^
                                      |
      +-------------------------------|--------------------------------+
      |                               |                                |
      |                          +----+----+                           |
      |                          | virtual |                           |
      |                          | PCI-PCI | (pci_dev)                 |
      |                          | bridge  |                           |
      |                          +----+----+                           |
      |                               |                                |
      |                               |Bus#3(pci_bus)                  |
      |                               |                                |
      |          +----------------------------------------+            |
      |          |                    |                   |            |
      |          |                    |                   |            |
      |          |03:00.0             |03:01.0            |03:02.0     |
      |     +----+----+          +----+----+         +----++---+       |
      |     | virtual |          | virtual |         | virtual |       |
      |     | PCI-PCI |pci_dev   | PCI-PCI |pci_dev  | PCI-PCI |pci_dev|
      |     | bridge  |          | bridge  |         | bridge  |       |
      |     +----+----+          +----+----+         +----+----+       |
      |          |                    |                   |            |
      |          |                    |                   |            |
      +----------|--------------------|-------------------|------------+
                 | Bus#4(pci_bus)     | Bus#5(pci_bus)    |Bus#6(pci_bus)
                 v                    v                   v

                   Figure 0.2 internal representation of PCIe Switch
                   (this is an example, the number could be different)

                            Bus 0(pci_bus)                      
                            +--------------------+<----+
                            |children(list_head) |     |
                            |                    |-+   |
                            +--------------------+ |   |
                                                   |   |
                                                   |   |
                    +------------------------------+   |
                    |                                  |
                    |                                  |
                    |        Bridge(pci_dev)           |                     
                    |       +--------------------+<----|---+--------------+
                    |       |subordinate(pci_bus)|-+   |   |              |
                    |       +--------------------+ |   |   |              |
                    |                              |   |   |              |
                    |                              |   |   |              |
                    |       Bus 1(pci_bus)         |   |   |              |
                    +--+--->+-------------------+<-+   |   |              |
                       |    |parent(pci_bus)    |------+   |              |
                       |    +-------------------+          |              |
                       |    |self(pci_dev)      |----------+              |
                       |    |bridge(device)     |                         |
                       |    +-------------------+                         |
                       |    |devices(list_head) |                         |
                       |    +--------+----------+                         |
                       |             |                                    |
                       |      ----+--+---+----                            |
   pci_dev             |          |      |          pci_dev               |
   +---------------+<--|----------+      +--------->+-----------------+   |
   |bus(pci_bus)   |---+                            |bus(pci_bus)     |   |
   +---------------+                                +-----------------+   |
   |dev.parent     |                                |dev.parent       |---+
   +---------------+                                +-----------------+

                  Figure 0.3 relationship between bridge/bus/child device
                  (this is an example, the number could be different
		   another version on web is http://tldp.org/LDP/tlk/dd/pci.html
		   Section 6.6.1)
