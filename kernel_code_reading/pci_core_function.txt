0. Preface
===============================================================================
This file contains the most used functions of pci subsystem initialization in
linux kernel. Definitly, this file is not complete and updated to the latest
code. While this file is just a note during my code reading.

Section 1. PCI bus enumeration
pci_create_root_bus(), pci_scan_child_bus(), pci_assign_unassigned_resources()
are the three most important functions for pci bus enumeration.

pci_bus_add_devices() and pci_find_bus() also helps during the bus
enumeration.

Section 2. Configuration space and resource related
Configuration space is a very important concept for pci devices, this is the
reason for me to list those functions which read/write the configuration
space. 

They are __pci_read_base(), pci_read_bridge_bases(),
pcie_bus_configure_settings().

Resource is another very important concept for pci devices. And actually the
resource information is in the configuration space. This is the reason I put
this category in the same section as the configuration space functions.

They are pci_assign_resource(), pci_reassign_resource(),
pci_update_resource(), pci_setup_bridge(), pci_enable_resources().

Section 3. SRIOV related
For SRIOV pci devices, there are two related functions.
pci_iov_init() is called in the pci enumeration stage.
pci_enable_sriov() is called in the device driver to setup other stuffs.

1. pci_create_root_bus()
===============================================================================
pci_create_root_bus(struct device *parent, int bus,
		struct pci_ops *ops, void *sysdata, struct list_head *resources)
	struct pci_host_bridge *host_bridge;
	host_bridge = kzalloc(sizeof(*host_bridge), GFP_KERNEL);

	struct pci_bus *b;
	b = pci_alloc_bus();

	struct device *dev;
	dev = kzalloc(sizeof(*dev), GFP_KERNEL);

	b->sysdata = sysdata;
	b->ops = ops;

	b2 = pci_find_bus(pci_domain_nr(b), bus);
	if (b2) goto err_out;

	dev->parent = parent;
	dev->release = pci_release_bus_bridge_dev;
	dev_set_name(dev, "pci%04x:%02x", pci_domain_nr(b), bus);
	error = device_register(dev);

	b->bridge = get_device(dev);
	device_enable_async_suspend(b->bridge);
	pci_set_bus_of_node(b);

	b->dev.class = &pcibus_class;
	b->dev.parent = b->bridge;
	dev_set_name(&b->dev, "%04x:%02x", pci_domain_nr(b), bus);
	error = device_register(&b->dev);
	pci_create_legacy_files(b);
	b->number = b->secondary = bus;

	host_bridge->bus = b;
	INIT_LIST_HEAD(&host_bridge->windows);

	/* Add initial resources to the bus */
	; add the resource in *resources* list to bus->resources list
	; well for a root bus, the *resources* list is retrieved from
	; hardware, etc, on x86 from ACPI, on power from FDT
	pci_bus_add_resource()

	list_add_tail(&host_bridge->list, &pci_host_bridges);
        list_add_tail(&b->node, &pci_root_buses);
                                                
                                                
                                                
                                                            
       host_bridge(struct pci_host_bridge)      
       +-------------------+                   
       | windows           |                              +->parent(first parameter of 
       +-------------------+                              |         pci_create_root_bus)
       |bus(struct pci_bus)|                              |
       +-------------------+                              +---------------------+
        |                                                                       |
        |                                                                       |
        |                                                 dev(struct device)    |
        |                                           +---->+----------------+    |
        |                                           |     |   parent       |----+
        |    pci_root_bus(struct pci_bus)           |     +----------------+          
        +--->+-------------------------------+      |     |                | 
             |dev(struct device)             |      |     |                |
             |   class = pcibus_class        |      |     +----------------+
             |   parent      ----------------|---+  |
             |                               |   |  |
             +-------------------------------+<--+  |
             |bridge(struct device)          |      |
             |                               |------+
             +-------------------------------+
             |self(struct pci_dev) = NULL    |
             +-------------------------------+
             |number = bus                   |
             +-------------------------------+  
             |secondary = bus                |  
             +-------------------------------+  
             |resources(list_head)           |  
             |     a list of io/mem resource |
             |     available for this bus    |  
             +-------------------------------+  

                Figure 1.1 relationship between pci_root_bus/host_bridge


1.1 pci_bus_add_resource(), add a res to bus->resources list
===============================================================================
pci_bus_add_resource(struct pci_bus *bus, struct resource *res,
			  unsigned int flags)
	struct pci_bus_resource *bus_res;

	bus_res = kzalloc(sizeof(struct pci_bus_resource), GFP_KERNEL);
	if (!bus_res) {
		dev_err(&bus->dev, "can't add %pR resource\n", res);
		return;
	}

	bus_res->res = res;
	bus_res->flags = flags;
	list_add_tail(&bus_res->list, &bus->resources);

2. pci_scan_child_bus(), give the a pci bus, create the sub pci tree
===============================================================================
this is the core function in the pci core to enumerate the pci tree. 
What it will do is:
* bus number assignment and reservation for VFs
* set the pci_dev->resource by reading BAR info
* call pci_read_bridge_bases() for bridge to set the io/mem limit

pci_scan_child_bus(struct pci_bus *bus)
	max = bus->secondary

	/* Go find them, Rover! */
	for (devfn = 0; devfn < 0x100; devfn += 8)
		pci_scan_slot(bus, devfn);

	/* Reserve buses for SR-IOV capability. */
	max += pci_iov_bus_range(bus);

	if (!bus->is_added) {
		dev_dbg(&bus->dev, "fixups for bus\n");
		; this is a platform depent code in which it
		; will call pci_read_bridge_bases() to assign the 
		; bus->resource[]
		pcibios_fixup_bus(bus);
		if (pci_is_root_bus(bus))
			bus->is_added = 1;
	}

	for (pass=0; pass < 2; pass++)
		list_for_each_entry(dev, &bus->devices, bus_list) {
			if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
			    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS)
				max = pci_scan_bridge(bus, dev, max, pass);
		}

	return max;

2.2 pci_is_root_bus()
===============================================================================
pci_is_root_bus(struct pci_bus *pbus)
	return !(pbus->parent);

the bus is a root bus when it doesn't have parent.

2.3 pci_scan_slot()
===============================================================================
pci_scan_slot(struct pci_bus *bus, int devfn)
	if (only_one_child(bus) && (devfn > 0))
		return 0; /* Already scanned the entire slot */

	dev = pci_scan_single_device(bus, devfn);
	if (!dev->is_added)
		nr++;

	; calculate fn based on different scheme and call
	pci_scan_single_device(bus, devfn + fn), nr++ if needed

	/* only one slot has pcie device */
	if (bus->self && nr)
		pcie_aspm_init_link_state(bus->self);

	return nr; return the number of newly find pci device

2.4 pci_scan_single_device()
===============================================================================
pci_scan_single_device(struct pci_bus *bus, int devfn)
	struct pci_dev *dev;

	dev = pci_scan_device(bus, devfn);

	pci_device_add(dev, bus);

2.4.1 pci_scan_device()
===============================================================================
pci_scan_device(struct pci_bus *bus, int devfn)
	struct pci_dev *dev;

	dev = alloc_pci_dev();

	dev->bus = bus;
	dev->devfn = devfn;
	dev->vendor = l & 0xffff;
	dev->device = (l >> 16) & 0xffff;

	pci_setup_device(dev);

2.4.1.1 pci_setup_device(), setup the newly found pci_dev
===============================================================================
; set the type, parent, and resource
pci_setup_device(struct pci_dev *dev )
	; get header type, 00h device, 01h bridge, 02h Card Bus
	if (pci_read_config_byte(dev, PCI_HEADER_TYPE, &hdr_type))

	dev->sysdata = dev->bus->sysdata;
	dev->dev.parent = dev->bus->bridge;
	dev->dev.bus = &pci_bus_type;
	dev->hdr_type = hdr_type & 0x7f;

	dev_set_name(&dev->dev, "%04x:%02x:%02x.%d", pci_domain_nr(dev->bus),
		     dev->bus->number, PCI_SLOT(dev->devfn),
		     PCI_FUNC(dev->devfn));

	; early fixups
	pci_fixup_device(pci_fixup_early, dev);

	switch(dev->hdr_typ) { ; three types
	case PCI_HEADER_TYPE_NORMAL:
		pci_read_irq(dev);
		pci_read_bases(dev, 6, PCI_ROM_ADDRESS);
		pci_read_config_word(dev, PCI_SUBSYSTEM_VENDOR_ID, &dev->subsystem_vendor);
		pci_read_config_word(dev, PCI_SUBSYSTEM_ID, &dev->subsystem_device);
	case PCI_HEADER_TYPE_BRIDGE:
		pci_read_irq(dev);
		dev->transparent = ((dev->class & 0xff) == 1);
		pci_read_bases(dev, 2, PCI_ROM_ADDRESS1);
		set_pcie_hotplug_bridge(dev);
		pos = pci_find_capability(dev, PCI_CAP_ID_SSVID);
		if (pos) {
			pci_read_config_word(dev, pos + PCI_SSVID_VENDOR_ID, &dev->subsystem_vendor);
			pci_read_config_word(dev, pos + PCI_SSVID_DEVICE_ID, &dev->subsystem_device);
		}
	case PCI_HEADER_TYPE_CARDBUS:
		pci_read_irq(dev);
		pci_read_bases(dev, 1, 0);
		pci_read_config_word(dev, PCI_CB_SUBSYSTEM_VENDOR_ID, &dev->subsystem_vendor);
		pci_read_config_word(dev, PCI_CB_SUBSYSTEM_ID, &dev->subsystem_device);
	}

	return 0;



               struct pci_dev
               +------------------------------------+
               |dev(struct device)                  |
               |   parent           ----------------|----+ 
               |   bus = &pci_bus_type              |    |
               +------------------------------------+    |
               |bus(pci_bus) attached to which bus  |    |
               |    bridge(device)                  |<---+ 
               +------------------------------------+
               |devfn (device/function number)      |      
               |vendor (vendor ID)                  |      
               |device (device ID)                  |      
               +------------------------------------+
               |resource                            |
               |    (an array of struct resource)   |
               |    retrieve addreess from BAR      |
               |                                    |
               |                                    |
               +------------------------------------+

               Figure 2.1 newly added pci_dev structure


2.4.1.1.1 pci_read_bases(), setup pci_dev->resource from BAR 
===============================================================================
pci_read_bases(struct pci_dev *dev, unsigned int howmany, int rom)
	; howmany/rom is determined by the pci_dev type
	for (pos = 0; pos < howmany; pos++) {
		struct resource *res = &dev->resource[pos];
		reg = PCI_BASE_ADDRESS_0 + (pos << 2);
		pos += __pci_read_base(dev, pci_bar_unknown, res, reg);
	}

	if (rom) {
		struct resource *res = &dev->resource[PCI_ROM_RESOURCE];
		dev->rom_base_reg = rom;
		res->flags = IORESOURCE_MEM | IORESOURCE_PREFETCH |
				IORESOURCE_READONLY | IORESOURCE_CACHEABLE |
				IORESOURCE_SIZEALIGN;
		__pci_read_base(dev, pci_bar_mem32, res, rom);
	}

2.4.2 pci_device_add()
===============================================================================
pci_device_add(struct pci_dev *dev, struct pci_bus *bus)
	device_initialize(&dev->dev);
	dev->dev.release = pci_release_dev;
	pci_dev_get(dev);

	dev->dev.dma_mask = &dev->dma_mask;
	dev->dev.dma_parms = &dev->dma_parms;
	dev->dev.coherent_dma_mask = 0xffffffffull;

	pci_set_dma_max_seg_size(dev, 65536);
	pci_set_dma_seg_boundary(dev, 0xffffffff);

	/* Fix up broken headers */
	pci_fixup_device(pci_fixup_header, dev);

	/* moved out from quirk header fixup code */
	pci_reassigndev_resource_alignment(dev);

	/* Clear the state_saved flag. */
	dev->state_saved = false;

	pci_init_capabilities(dev);

	; add to the bus->devices list
	list_add_tail(&dev->bus_list, &bus->devices);

2.4.2.1 pci_init_capabilities()
===============================================================================
pci_init_capabilities(struct pci_dev *dev)
	/* MSI/MSI-X list */
	pci_msi_init_pci_dev(dev);

	/* Buffers for saving PCIe and PCI-X capabilities */
	pci_allocate_cap_save_buffers(dev);

	/* Power Management */
	pci_pm_init(dev);
	platform_pci_wakeup_init(dev);

	/* Vital Product Data */
	pci_vpd_pci22_init(dev);

	/* Alternative Routing-ID Forwarding */
	pci_enable_ari(dev);

	/* Single Root I/O Virtualization */
	; initialize the sriov when pci enumeration
	pci_iov_init(dev);

	/* Enable ACS P2P upstream forwarding */
	pci_enable_acs(dev);

2.5 pci_scan_bridge()
===============================================================================
pci_scan_bridge(struct pci_bus *bus, struct pci_dev *dev, int max, int pass)
 ; bus is the bus where the dev attached to 
 ; dev is a pci_dev whose type is brige or cardbus
 ; max is the max bus number we have met
 ; pass indidate the pass index
 * We need to process bridges in two passes -- first we scan those
 * already configured by the BIOS and after we are done with all of
 * them, we proceed to assigning numbers to the remaining buses in
 * order to avoid overlaps between old and new bus numbers.

 	; for both bridge and cardbus, 0x18-0x1a is the bus number
	; retrieve the bus number from bridge which is set 
	; by firmware
	pci_read_config_dword(dev, PCI_PRIMARY_BUS, &buses);
	primary = buses & 0xFF;
	secondary = (buses >> 8) & 0xFF;
	subordinate = (buses >> 16) & 0xFF;

	; check the bus number
	; 1. primary should equals to bus->number
	; 2. secondary bus number should bigger than primary
	if (!pass &&
	    (primary != bus->number || secondary <= bus->number)) {
		dev_dbg(&dev->dev, "bus configuration invalid, reconfiguring\n");
		broken = 1;
	}

	; disable MasterAbortMode, to do the real work
	pci_write_config_word(dev, PCI_BRIDGE_CONTROL,
			      bctl & ~PCI_BRIDGE_CTL_MASTER_ABORT);


	; pass 0, 
	; the normal case
		child = pci_find_bus(pci_domain_nr(bus), secondary);
		if (!child) {
			child = pci_add_new_bus(bus, dev, secondary);
			if (!child)
				goto out;
			child->primary = primary;
			child->subordinate = subordinate;
			child->bridge_ctl = bctl;
		}

		cmax = pci_scan_child_bus(child);
		if (cmax > max)
			max = cmax;
		if (child->subordinate > max)
			max = child->subordinate;
	
	; pass 1
	; handle the bridge which is not configured well by firmware
		/* Clear errors */
		pci_write_config_word(dev, PCI_STATUS, 0xffff);

		; prevent assigning a bus number that already
		; exist
		child = pci_find_bus(pci_domain_nr(bus), max+1);
		if (!child) {
			child = pci_add_new_bus(bus, dev, ++max);
			if (!child)
				goto out;
		}
		buses = (buses & 0xff000000)
		      | ((unsigned int)(child->primary)     <<  0)
		      | ((unsigned int)(child->secondary)   <<  8)
		      | ((unsigned int)(child->subordinate) << 16);

		; write the device
		pci_write_config_dword(dev, PCI_PRIMARY_BUS, buses);

		pci_fixup_parent_subordinate_busnr(child, max);
		/* Now we can scan all subordinate buses... */
		max = pci_scan_child_bus(child);
		/*
		 * now fix it up again since we have found
		 * the real value of max.
		 */
		pci_fixup_parent_subordinate_busnr(child, max);

		child->subordnate = max;
		pci_write_config_byte(dev, PCI_SUBORDINATE_BUSï¼Œ max);
	return max;

2.5.1 pci_add_new_bus()
===============================================================================
pci_add_new_bus(struct pci_bus *parent, struct pci_dev *dev, int busnr)
	struct pci_bus *child;

	child = pci_alloc_child_bus(parent, dev, busnr);
	if (child) {
		down_write(&pci_bus_sem);
		list_add_tail(&child->node, &parent->children);
		up_write(&pci_bus_sem);
	}
	return child;

2.5.1.1 pci_alloc_child_bus()
===============================================================================
pci_alloc_child_bus(struct pci_bus *parent, struct pci_dev *bridge, int busnr)
	child = pci_alloc_bus()

	child->parent = parent;
	child->ops = parent->ops;
	child->sysdata = parent->sysdata;

	child->dev.class = &pcibus_class;
	dev_set_name(&child->dev, ...);

	child->number = child->secondary = busnr;
	child->primary = parent->secondary;
	child->subordinate = 0xff;

	if (!bridge)
		return child;

	child->self = bridge;
	child->bridge = get_device(&bridge->dev);
	pci_set_bus_of_node(child);
	pci_set_bus_speed(child);

	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++) {
		child->resource[i] = &bridge->resource[PCI_BRIDGE_RESOURCES+i];
		child->resource[i]->name = child->name;
	}
	
	; a bridge pci_dev has its subordinate
	bridge->subordinate = child;

	return child;

             -------+---------      Bus 00(pci_bus) <-------------------+
                    |                 +---secondary(00) <---------------|------+
        +-----------+--------+                                          |      |
        |     00:02.0        |P2P bridge(pci_dev)                       |      |
        | PCIe-PCI bridge    |<--------------------------------------------+   |
        +--------------------+                                          |  |   |
        |dev(device)         |<----------------------------------------------+ |
        +---------------------                                          |  | | |
        |subordinate(pci_bus)|----------+                               |  | | |
        +-----------+--------+          |                               |  | | |
                    |                   +------->+--------------------+ |  | | |
                    |                            |parent              |-+  | | |
         +---------------------+  Bus 02(pci_bus)+--------------------+    | | |
         |                     |                 |self(pci_dev)       |----+ | |
         |                     |                 +--------------------+      | |
         |                     |                 |bridge(device)      |------+ |                              
         |                     |                 +--------------------+        |                              
         |                     |                 |primary             |--------+                              
         |                     |                 +--------------------+                                       
         |                     |                 |resource(struct *)  |            
         |                     |                 |  point to corres-  |
    +----v----+           +----v----+            |  ponding bridge res|
    | 02:00.0 |           | 02:01.0 |            |  in self, which is |
    |(pci_dev)|           |(pci_dev)|            |  the bridge        |
    +---------+           +---------+            +--------------------+

                     Figure 2.2 newly added pci_bus and its parent
                     (this is an example, the number could be different)

2.5.2 pci_fixup_parent_subordinate_busnr(), fix parent bus number
===============================================================================
pci_fixup_parent_subordinate_busnr(struct pci_bus *child, int max)
	struct pci_bus *parent = child->parent;

	/* Attempts to fix that up are really dangerous unless
	   we're going to re-assign all bus numbers. */
	if (!pcibios_assign_all_busses())
		return;

	while (parent->parent && parent->subordinate < max) {
		parent->subordinate = max;
		pci_write_config_byte(parent->self, PCI_SUBORDINATE_BUS, max);
		parent = parent->parent;
	}

3. pci_assign_unassigned_resources(), go throught the resources and assign them
===============================================================================
pci_assign_unassigned_resources(void)
	struct pci_bus *bus;
	LIST_HEAD(realloc_head); 
	struct list_head *add_list = NULL;
	int tried_times = 0;
	enum release_type rel_type = leaf_only;
	LIST_HEAD(fail_head);
	struct pci_dev_resource *fail_res;
	unsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM |
				  IORESOURCE_PREFETCH;
	int pci_try_num = 1;

	/* don't realloc if asked to do so */
	pci_realloc_detect(); set the pci_realloc_detect variable
	if (pci_realloc_enabled()) {
		; if realloc is enabled, set the pci_try_num 
		; to max_depth + 1
		int max_depth = pci_get_max_depth();

		pci_try_num = max_depth + 1;
		printk(KERN_DEBUG "PCI: max bus depth: %d pci_try_num: %d\n",
			 max_depth, pci_try_num);
	}

again:
	/*
	 * last try will use add_list, otherwise will try good to have as
	 * must have, so can realloc parent bridge resource
	 */
	if (tried_times + 1 == pci_try_num)
		add_list = &realloc_head;

	/* Depth first, calculate sizes and alignments of all
	   subordinate buses. */
	; go through all root bus
	; add_list is the additional resource request
	list_for_each_entry(bus, &pci_root_buses, node)
		__pci_bus_size_bridges(bus, add_list);

	/* Depth last, allocate resources and update the hardware. */
	list_for_each_entry(bus, &pci_root_buses, node)
		__pci_bus_assign_resources(bus, add_list, &fail_head);
	if (add_list)
		BUG_ON(!list_empty(add_list));
	tried_times++;

	/* any device complain? */
	if (list_empty(&fail_head))
		goto enable_and_dump;

	if (tried_times >= pci_try_num) {
		if (pci_realloc_enable == undefined)
			printk(KERN_INFO "Some PCI device resources are unassigned, try booting with pci=realloc\n");
		else if (pci_realloc_enable == auto_enabled)
			printk(KERN_INFO "Automatically enabled pci realloc, if you have problem, try booting with pci=realloc=off\n");

		free_list(&fail_head);
		goto enable_and_dump;
	}

	printk(KERN_DEBUG "PCI: No. %d try to assign unassigned res\n",
			 tried_times + 1);

	/* third times and later will not check if it is leaf */
	if ((tried_times + 1) > 2)
		rel_type = whole_subtree;

	/*
	 * Try to release leaf bridge's resources that doesn't fit resource of
	 * child device under that bridge
	 */
	list_for_each_entry(fail_res, &fail_head, list) {
		bus = fail_res->dev->bus;
		pci_bus_release_bridge_resources(bus,
						 fail_res->flags & type_mask,
						 rel_type);
	}
	/* restore size and flags */
	list_for_each_entry(fail_res, &fail_head, list) {
		struct resource *res = fail_res->res;

		res->start = fail_res->start;
		res->end = fail_res->end;
		res->flags = fail_res->flags;
		if (fail_res->dev->subordinate)
			res->flags = 0;
	}
	free_list(&fail_head);

	goto again;

enable_and_dump:
	/* Depth last, update the hardware. */
	list_for_each_entry(bus, &pci_root_buses, node)
		pci_enable_bridges(bus);

	/* dump the resource on buses */
	; go through each pci root bus and dump it
	list_for_each_entry(bus, &pci_root_buses, node)
		pci_bus_dump_resources(bus);

3.1 __pci_bus_size_bridges(), depth first
===============================================================================
__pci_bus_size_bridges(struct pci_bus *bus, struct list_head *realloc_head)
	struct pci_dev *dev;
	unsigned long mask, prefmask;
	resource_size_t additional_mem_size = 0, additional_io_size = 0;

	; go through all the device of the bus
	list_for_each_entry(dev, &bus->devices, bus_list) {
		struct pci_bus *b = dev->subordinate;
		if (!b)
			continue;

		switch (dev->class >> 8) {
		case PCI_CLASS_BRIDGE_CARDBUS:
			pci_bus_size_cardbus(b, realloc_head);
			break;

		case PCI_CLASS_BRIDGE_PCI:
		default:
			__pci_bus_size_bridges(b, realloc_head);
			break;
		}
	}

	/* The root bus? */
	if (!bus->self)
		return;

	switch (bus->self->class >> 8) {
	case PCI_CLASS_BRIDGE_CARDBUS:
		/* don't size cardbuses yet. */
		break;

	case PCI_CLASS_BRIDGE_PCI:
		pci_bridge_check_ranges(bus);
		if (bus->self->is_hotplug_bridge) {
			; if the bridge support hotplug
			; add additional size
			additional_io_size  = pci_hotplug_io_size;
			additional_mem_size = pci_hotplug_mem_size;
		}
		/*
		 * Follow thru
		 */
	default:
		pbus_size_io(bus, realloc_head ? 0 : additional_io_size,
			     additional_io_size, realloc_head);

		/* If the bridge supports prefetchable range, size it
		   separately. If it doesn't, or its prefetchable window
		   has already been allocated by arch code, try
		   non-prefetchable range for both types of PCI memory
		   resources. */
		mask = IORESOURCE_MEM;
		prefmask = IORESOURCE_MEM | IORESOURCE_PREFETCH;
		if (pbus_size_mem(bus, prefmask, prefmask,
				  realloc_head ? 0 : additional_mem_size,
				  additional_mem_size, realloc_head))
			mask = prefmask; /* Success, size non-prefetch only. */
		else
			additional_mem_size += additional_mem_size;
		pbus_size_mem(bus, mask, IORESOURCE_MEM,
				realloc_head ? 0 : additional_mem_size,
				additional_mem_size, realloc_head);
		break;
	}

3.1.1 pci_bridge_check_ranges(), check whether the bridge support io/pref mem base/limit
===============================================================================
pci_bridge_check_ranges(struct pci_bus *bus)
	u16 io;
	u32 pmem;
	struct pci_dev *bridge = bus->self;
	struct resource *b_res;

	; b_res point to the first resource of bridge
	b_res = &bridge->resource[PCI_BRIDGE_RESOURCES];
	; so bridge must support IOMEM?
	b_res[1].flags |= IORESOURCE_MEM;

	; If a bridge does not implement an I/O address range, 
	; then both the I/O Base and I/O Limit registers must be implemented 
	; as read-only registers that return zero when read.
	pci_read_config_word(bridge, PCI_IO_BASE, &io);
	if (!io) {
		pci_write_config_word(bridge, PCI_IO_BASE, 0xf0f0);
		pci_read_config_word(bridge, PCI_IO_BASE, &io);
 		pci_write_config_word(bridge, PCI_IO_BASE, 0x0);
 	}
 	if (io)
		b_res[0].flags |= IORESOURCE_IO;
	/*  DECchip 21050 pass 2 errata: the bridge may miss an address
	    disconnect boundary by one PCI data phase.
	    Workaround: do not use prefetching on this device. */
	if (bridge->vendor == PCI_VENDOR_ID_DEC && bridge->device == 0x0001)
		return;
	pci_read_config_dword(bridge, PCI_PREF_MEMORY_BASE, &pmem);
	if (!pmem) {
		pci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE,
					       0xfff0fff0);
		pci_read_config_dword(bridge, PCI_PREF_MEMORY_BASE, &pmem);
		pci_write_config_dword(bridge, PCI_PREF_MEMORY_BASE, 0x0);
	}
	if (pmem) {
		b_res[2].flags |= IORESOURCE_MEM | IORESOURCE_PREFETCH;
		if ((pmem & PCI_PREF_RANGE_TYPE_MASK) ==
		    PCI_PREF_RANGE_TYPE_64) {
			b_res[2].flags |= IORESOURCE_MEM_64;
			b_res[2].flags |= PCI_PREF_RANGE_TYPE_64;
		}
	}

	/* double check if bridge does support 64 bit pref */
	if (b_res[2].flags & IORESOURCE_MEM_64) {
		u32 mem_base_hi, tmp;
		pci_read_config_dword(bridge, PCI_PREF_BASE_UPPER32,
					 &mem_base_hi);
		pci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32,
					       0xffffffff);
		pci_read_config_dword(bridge, PCI_PREF_BASE_UPPER32, &tmp);
		if (!tmp)
			b_res[2].flags &= ~IORESOURCE_MEM_64;
		pci_write_config_dword(bridge, PCI_PREF_BASE_UPPER32,
				       mem_base_hi);
	}

3.1.2 pbus_size_io(), allocate the necessary resource to the bridge, if additional resource needed, add it to realloc_head
===============================================================================
; 1. first it will calculate all the necessary resource requirement under current bus.
;    including normal resource, bridge resource and iov resource
; 2. and set the size to one of the bridge's resource, b_res
pbus_size_io(struct pci_bus *bus, resource_size_t min_size,
		resource_size_t add_size, struct list_head *realloc_head)
	struct pci_dev *dev;
	; b_res point to the corresponding bridge resource
	struct resource *b_res = find_free_bus_resource(bus, IORESOURCE_IO);
	unsigned long size = 0, size0 = 0, size1 = 0;
	resource_size_t children_add_size = 0;
	resource_size_t io_align;

	; no free resource, go
	if (!b_res)
 		return;

	; go through the devices under this bus
	list_for_each_entry(dev, &bus->devices, bus_list) {
		int i;

		for (i = 0; i < PCI_NUM_RESOURCES; i++) {
			struct resource *r = &dev->resource[i];
			unsigned long r_size;

			if (r->parent || !(r->flags & IORESOURCE_IO))
				continue;
			r_size = resource_size(r);

			if (r_size < 0x400) 1K
				/* Might be re-aligned for ISA */
				size += r_size;
			else
				size1 += r_size;

			if (realloc_head); ?
				children_add_size += get_res_add_size(realloc_head, r);
		}
	}

	; get alignment for io
	io_align = window_alignment(bus, IORESOURCE_IO);
	; calculate size + size1
	size0 = calculate_iosize(size, min_size, size1,
			resource_size(b_res), io_align);
	; get the final additional size
	if (children_add_size > add_size)
		add_size = children_add_size;
	; if the add_size is 0, which means no additional size needed,
	; size1 = size0.
	; otherwise, 
	; calculate size + (add_size + size1)
	size1 = (!realloc_head || (realloc_head && !add_size)) ? size0 :
		calculate_iosize(size, min_size, add_size + size1,
			resource_size(b_res), io_align);
	if (!size0 && !size1) {
		; io resource is not necessary
		if (b_res->start || b_res->end)
			dev_info(&bus->self->dev, "disabling bridge window "
				 "%pR to [bus %02x-%02x] (unused)\n", b_res,
				 bus->secondary, bus->subordinate);
		b_res->flags = 0;
		return;
	}

	/* Alignment of the IO window is always 4K */
	; b_res size is size0, which is MUST met requirement
	b_res->start = io_align;
	b_res->end = b_res->start + size0 - 1;
	b_res->flags |= IORESOURCE_STARTALIGN;
	if (size1 > size0 && realloc_head) {
		; size1 > size0 means we need additional resource
		; additional size is size1-size0
		; and add to realloc_head list
		add_to_list(realloc_head, bus->self, b_res, size1-size0, 4096);
		dev_printk(KERN_DEBUG, &bus->self->dev, "bridge window "
				 "%pR to [bus %02x-%02x] add_size %lx\n", b_res,
				 bus->secondary, bus->subordinate, size1-size0);
	}

3.1.2.1 calculate_iosize(), calculate size + size1 with alignment
===============================================================================
calculate_iosize(resource_size_t size,
		resource_size_t min_size,
		resource_size_t size1,
		resource_size_t old_size,
		resource_size_t align)
	if (size < min_size)
		size = min_size;
	if (old_size == 1 )
		old_size = 0;
	/* To be fixed in 2.5: we should have sort of HAVE_ISA
	   flag in the struct pci_bus. */
#if defined(CONFIG_ISA) || defined(CONFIG_EISA)
	size = (size & 0xff) + ((size & ~0xffUL) << 2);
#endif
	size = ALIGN(size + size1, align);
	if (size < old_size)
		size = old_size;
	return size;

3.1.3 pbus_size_mem(), find one proper parent resource and allocate it, for additional resource add to list
===============================================================================
; mask      which is used to filter the mem resource
; type      which type mem resource it is looking for
pbus_size_mem(struct pci_bus *bus, unsigned long mask,
			 unsigned long type, resource_size_t min_size,
			resource_size_t add_size,
			struct list_head *realloc_head)
	struct pci_dev *dev;
	resource_size_t min_align, align, size, size0, size1;
	resource_size_t aligns[12];	/* Alignments from 1Mb to 2Gb */
	int order, max_order;
	struct resource *b_res = find_free_bus_resource(bus, type);
	unsigned int mem64_mask = 0;
	resource_size_t children_add_size = 0;

	; no free bus resource
	if (!b_res)
		return 0;

	memset(aligns, 0, sizeof(aligns));
	max_order = 0;
	size = 0;

	mem64_mask = b_res->flags & IORESOURCE_MEM_64;
	b_res->flags &= ~IORESOURCE_MEM_64;

	; go throught the devices under this bus
	; calculate un-allocated resouse size 
	list_for_each_entry(dev, &bus->devices, bus_list) {
		int i;

		for (i = 0; i < PCI_NUM_RESOURCES; i++) {
			struct resource *r = &dev->resource[i];
			resource_size_t r_size;

			; if allocated, type not match, skip
			if (r->parent || (r->flags & mask) != type)
				continue;
			r_size = resource_size(r);
#ifdef CONFIG_PCI_IOV
			/* put SRIOV requested res to the optional list */
			if (realloc_head && i >= PCI_IOV_RESOURCES &&
					i <= PCI_IOV_RESOURCE_END) {
				r->end = r->start - 1;
				add_to_list(realloc_head, dev, r, r_size, 0/* dont' care */);
				children_add_size += r_size;
				continue;
			}
#endif
			/* For bridges size != alignment */
			; get alignment order
			align = pci_resource_alignment(dev, r);
			order = __ffs(align) - 20;
			if (order > 11) {
				dev_warn(&dev->dev, "disabling BAR %d: %pR "
					 "(bad alignment %#llx)\n", i, r,
					 (unsigned long long) align);
				r->flags = 0;
				continue;
			}
			size += r_size;
			if (order < 0)
				order = 0;
			/* Exclude ranges with size > align from
			   calculation of the alignment. */
			if (r_size == align)
				aligns[order] += align;
			if (order > max_order)
				max_order = order;
			mem64_mask &= r->flags & IORESOURCE_MEM_64;

			if (realloc_head) ; for what?
				children_add_size += get_res_add_size(realloc_head, r);
		}
	}
	; calculate the alignment
	align = 0;
	min_align = 0;
	for (order = 0; order <= max_order; order++) {
		resource_size_t align1 = 1;

		align1 <<= (order + 20);

		if (!align)
			min_align = align1;
		else if (ALIGN(align + min_align, min_align) < align1)
			min_align = align1 >> 1;
		align += aligns[order];
	}

	; calculate size + 0
	size0 = calculate_memsize(size, min_size, 0, resource_size(b_res), min_align);
	if (children_add_size > add_size)
		add_size = children_add_size;
	; calculate size + add_size
	size1 = (!realloc_head || (realloc_head && !add_size)) ? size0 :
		calculate_memsize(size, min_size, add_size,
				resource_size(b_res), min_align);

	; sounds no need to have this resource
	if (!size0 && !size1) {
		if (b_res->start || b_res->end)
			dev_info(&bus->self->dev, "disabling bridge window "
				 "%pR to [bus %02x-%02x] (unused)\n", b_res,
				 bus->secondary, bus->subordinate);
		b_res->flags = 0;
		return 1;
	}

	; allocate the resource with size0
	b_res->start = min_align;
	b_res->end = size0 + min_align - 1;
	b_res->flags |= IORESOURCE_STARTALIGN | mem64_mask;
	if (size1 > size0 && realloc_head) {
		; add the additional resource request (size1-size0) to list
		add_to_list(realloc_head, bus->self, b_res, size1-size0, min_align);
		dev_printk(KERN_DEBUG, &bus->self->dev, "bridge window "
				 "%pR to [bus %02x-%02x] add_size %llx\n", b_res,
				 bus->secondary, bus->subordinate, (unsigned long long)size1-size0);
	}
	return 1;

3.1.3.1 calculate_memsize(), calculate size + size1 with alignment
===============================================================================
calculate_memsize(resource_size_t size,
		resource_size_t min_size,
		resource_size_t size1,
		resource_size_t old_size,
		resource_size_t align)
	if (size < min_size)
		size = min_size;
	if (old_size == 1 )
		old_size = 0;
	if (size < old_size)
		size = old_size;
	size = ALIGN(size + size1, align);
	return size;

3.1.4 find_free_bus_resource(), go through the resource of a bus and find a *free* one with the same type
===============================================================================
static struct resource *find_free_bus_resource(struct pci_bus *bus, unsigned long type)
{
	int i;
	struct resource *r;
	unsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM |
				  IORESOURCE_PREFETCH;

	pci_bus_for_each_resource(bus, r, i) {
		if (r == &ioport_resource || r == &iomem_resource)
			continue;
		if (r && (r->flags & type_mask) == type && !r->parent)
			return r;
	}
	return NULL;
}

3.1.4.1 pci_bus_for_each_resource()
===============================================================================
#define pci_bus_for_each_resource(bus, res, i)				\
	for (i = 0;							\
	    (res = pci_bus_resource_n(bus, i)) || i < PCI_BRIDGE_RESOURCE_NUM; \
	     i++)

; from 0-3, return bus->resource[], which points to its bridge
; then go throught the bus->resources list
struct resource *pci_bus_resource_n(const struct pci_bus *bus, int n)
{
	struct pci_bus_resource *bus_res;

	if (n < PCI_BRIDGE_RESOURCE_NUM)
		return bus->resource[n];

	n -= PCI_BRIDGE_RESOURCE_NUM;
	list_for_each_entry(bus_res, &bus->resources, list) {
		if (n-- == 0)
			return bus_res->res;
	}
	return NULL;
}

3.2 __pci_bus_assign_resources(), allocate the resoueces with realloc_head contain the additional resource 
===============================================================================
; realloc_head contains the list of resource which want additional resource
__pci_bus_assign_resources(const struct pci_bus *bus,
					 struct list_head *realloc_head,
					 struct list_head *fail_head)
	struct pci_bus *b;
	struct pci_dev *dev;

	; this will assign resource, if succeed, apply to hardware  
	pbus_assign_resources_sorted(bus, realloc_head, fail_head);

	list_for_each_entry(dev, &bus->devices, bus_list) {
		b = dev->subordinate;
		if (!b)
			continue;

		__pci_bus_assign_resources(b, realloc_head, fail_head);

		switch (dev->class >> 8) {
		case PCI_CLASS_BRIDGE_PCI:
			; apply the bridge resource to hardware
			if (!pci_is_enabled(dev))
				pci_setup_bridge(b);
			break;

		case PCI_CLASS_BRIDGE_CARDBUS:
			pci_setup_cardbus(b);
			break;

		default:
			dev_info(&dev->dev, "not setting up bridge for bus "
				 "%04x:%02x\n", pci_domain_nr(b), b->number);
			break;
		}
	}

3.2.1 pbus_assign_resources_sorted()
===============================================================================
; realloc_head contains the additional resource request
pbus_assign_resources_sorted(const struct pci_bus *bus,
					 struct list_head *realloc_head,
					 struct list_head *fail_head)
	struct pci_dev *dev;
	LIST_HEAD(head);

	; call on each device of this bus
	list_for_each_entry(dev, &bus->devices, bus_list)
		__dev_sort_resources(dev, &head);

	; now we get the unallocated resource in *head*,
	; including normal device resource, bridge device resource, iov resource
	; 
	__assign_resources_sorted(&head, realloc_head, fail_head);


3.2.1.1 __dev_sort_resources(), unallocated resource is add to head
===============================================================================
__dev_sort_resources(struct pci_dev *dev,
				 struct list_head *head)
	u16 class = dev->class >> 8;

	/* Don't touch classless devices or host bridges or ioapics.  */
	if (class == PCI_CLASS_NOT_DEFINED || class == PCI_CLASS_BRIDGE_HOST)
		return;

	/* Don't touch ioapic devices already enabled by firmware */
	if (class == PCI_CLASS_SYSTEM_PIC) {
		u16 command;
		pci_read_config_word(dev, PCI_COMMAND, &command);
		if (command & (PCI_COMMAND_IO | PCI_COMMAND_MEMORY))
			return;
	}

	; add the unallocated resource to list *head*
	pdev_sort_resources(dev, head);

3.2.1.1.1 pdev_sort_resources(), sort resources by alignment
===============================================================================
; go through a particular device's resource, including normal device resource,
; bridge device resource, and iov resource.
; add those unassigned resource to *head* list, in the order of alignment
pdev_sort_resources(struct pci_dev *dev, struct list_head *head)
	int i;

	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
		struct resource *r;
		struct pci_dev_resource *dev_res, *tmp;
		resource_size_t r_align;
		struct list_head *n;

		r = &dev->resource[i];

		if (r->flags & IORESOURCE_PCI_FIXED)
			continue;

		; disabled, or already allocated 
		if (!(r->flags) || r->parent)
			continue;

		r_align = pci_resource_alignment(dev, r);
		if (!r_align) {
			dev_warn(&dev->dev, "BAR %d: %pR has bogus alignment\n",
				 i, r);
			continue;
		}

		tmp = kzalloc(sizeof(*tmp), GFP_KERNEL);
		if (!tmp)
			panic("pdev_sort_resources(): "
			      "kmalloc() failed!\n");
		tmp->res = r;
		tmp->dev = dev;

		/* fallback is smallest one or list is empty*/
		n = head;
		list_for_each_entry(dev_res, head, list) {
			resource_size_t align;

			align = pci_resource_alignment(dev_res->dev,
							 dev_res->res);

			if (r_align > align) {
				n = &dev_res->list;
				break;
			}
		}
		/* Insert it just before n*/
		list_add_tail(&tmp->list, n);
	}

3.2.1.2 __assign_resources_sorted(), try to assign those resources
===============================================================================
; head is a list of resources which are required to meet
; realloc_head is the additional resource
__assign_resources_sorted(struct list_head *head,
				 struct list_head *realloc_head,
				 struct list_head *fail_head)
	/*
	 * Should not assign requested resources at first.
	 *   they could be adjacent, so later reassign can not reallocate
	 *   them one by one in parent resource window.
	 * Try to assign requested + add_size at begining
	 *  if could do that, could get out early.
	 *  if could not do that, we still try to assign requested at first,
	 *    then try to reassign add_size for some resources.
	 */
	LIST_HEAD(save_head);
	LIST_HEAD(local_fail_head);
	struct pci_dev_resource *save_res;
	struct pci_dev_resource *dev_res;

	/* Check if optional add_size is there */
	; no additional request, jump to the end
	if (!realloc_head || list_empty(realloc_head))
		goto requested_and_reassign;

	/* Save original start, end, flags etc at first */
	; one copy of head list
	list_for_each_entry(dev_res, head, list) {
		if (add_to_list(&save_head, dev_res->dev, dev_res->res, 0, 0)) {
			free_list(&save_head);
			goto requested_and_reassign;
		}
	}

	/* Update res in head list with add_size in realloc_head list */
	; previously the head list contains the must meet resource requirement
	; no we expand those required resource with additional requirement
	list_for_each_entry(dev_res, head, list)
		dev_res->res->end += get_res_add_size(realloc_head,
							dev_res->res);

	/* Try updated head list with add_size added */
	; now the head list has merged with required and additional request
	; after doing assignment, the local_fail_head has the failed request
	assign_requested_resources_sorted(head, &local_fail_head);

	/* all assigned with add_size ? */
	; no fail, which means the system meets our required and additional
	; resource request, perfect
	if (list_empty(&local_fail_head)) {
		; everything is perfect
		; return
		/* Remove head list from realloc_head list */
		list_for_each_entry(dev_res, head, list)
			remove_from_list(realloc_head, dev_res->res);
		free_list(&save_head);
		free_list(head);
		return;
	}

	free_list(&local_fail_head);
	/* Release assigned resource */
	;release every met resource, could we improve a little?
	list_for_each_entry(dev_res, head, list)
		if (dev_res->res->parent)
			release_resource(dev_res->res);

	/* Restore start/end/flags from saved list */
	list_for_each_entry(save_res, &save_head, list) {
		struct resource *res = save_res->res;

		res->start = save_res->start;
		res->end = save_res->end;
		res->flags = save_res->flags;
	}
	free_list(&save_head);

requested_and_reassign:
	/* Satisfy the must-have resource requests */
	; ok, head contains the must-have request
	assign_requested_resources_sorted(head, fail_head);

	/* Try to satisfy any additional optional resource requests */
	; realloc_head contains the additional request
	if (realloc_head)
		reassign_resources_sorted(realloc_head, head);
	free_list(head);

3.2.1.2.1 assign_requested_resources_sorted(), assign the resource in head list
===============================================================================
; head       a list with must meet resource requirement
; fail_head

; with a list of resources, it will find a proper parent of each resource and 
; assign this to the parent
assign_requested_resources_sorted(struct list_head *head,
				 struct list_head *fail_head)
	struct resource *res;
	struct pci_dev_resource *dev_res;
	int idx;

	; go through the head list
	list_for_each_entry(dev_res, head, list) {
		res = dev_res->res;
		idx = res - &dev_res->dev->resource[0];
		if (resource_size(res) &&
		    pci_assign_resource(dev_res->dev, idx)) {
			if (fail_head && !pci_is_root_bus(dev_res->dev->bus)) {
				/*
				 * if the failed res is for ROM BAR, and it will
				 * be enabled later, don't add it to the list
				 */
				if (!((idx == PCI_ROM_RESOURCE) &&
				      (!(res->flags & IORESOURCE_ROM_ENABLE))))
					add_to_list(fail_head,
						    dev_res->dev, res,
						    0 /* dont care */,
						    0 /* dont care */);
			}
			; a failed resource will be reset
			reset_resource(res);
		}
	}

3.2.1.2.2 reassign_resources_sorted(), satisfy any additional resource requests
===============================================================================
; realloc_head a list of additional request
; head a list of 
reassign_resources_sorted(struct list_head *realloc_head,
		struct list_head *head)
	struct resource *res;
	struct pci_dev_resource *add_res, *tmp;
	struct pci_dev_resource *dev_res;
	resource_size_t add_size;
	int idx;

	; go throught the realloc_head list
	; each one represent additional resource request
	list_for_each_entry_safe(add_res, tmp, realloc_head, list) {
		bool found_match = false;

		res = add_res->res;
		/* skip resource that has been reset */
		; one of the reason of reset is failed to assign it in 
		; assign_requested_resources_sorted()
		if (!res->flags)
			goto out;

		/* skip this resource if not found in head list */
		list_for_each_entry(dev_res, head, list) {
			if (dev_res->res == res) {
				found_match = true;
				break;
			}
		}
		; if not found in head, skip
		if (!found_match)/* just skip */
			continue;

		idx = res - &add_res->dev->resource[0];
		add_size = add_res->add_size;
		if (!resource_size(res)) {
			res->start = add_res->start;
			res->end = res->start + add_size - 1;
			if (pci_assign_resource(add_res->dev, idx))
				reset_resource(res);
		} else {
			resource_size_t align = add_res->min_align;
			res->flags |= add_res->flags &
				 (IORESOURCE_STARTALIGN|IORESOURCE_SIZEALIGN);
			if (pci_reassign_resource(add_res->dev, idx,
						  add_size, align))
				dev_printk(KERN_DEBUG, &add_res->dev->dev,
					   "failed to add %llx res[%d]=%pR\n",
					   (unsigned long long)add_size,
					   idx, res);
		}
out:
		list_del(&add_res->list);
		kfree(add_res);
	}

3.3 pci_bus_release_bridge_resources(), release the io/mem window on a bridge
===============================================================================
; try to release pci bridge resources that is from leaf bridge,
; so we can allocate big new one later
; bus     which pci bus it tries to release the resource
; type    which type resource it will release, IORESOURCE_IO,IORESOURCE_MEM,IORESOURCE_PREFETCH 	
; rel_tpe leaf_only or whole_subtree
pci_bus_release_bridge_resources(struct pci_bus *bus,
						   unsigned long type,
						   enum release_type rel_type)
	struct pci_dev *dev;
	bool is_leaf_bridge = true;

	list_for_each_entry(dev, &bus->devices, bus_list) {
		; dev->subordinate is not null means this pci device
		; is a bridge
		; which means on current pci bus *bus* one bridge is
		; attached.
		; which mean the current pci bus is not a leaf bus
		struct pci_bus *b = dev->subordinate;
		if (!b)
			continue;

		is_leaf_bridge = false;

		if ((dev->class >> 8) != PCI_CLASS_BRIDGE_PCI)
			continue;

		; if we are decided to go through the whole tree
		; we call ourself on the child bus
		if (rel_type == whole_subtree)
			pci_bus_release_bridge_resources(b, type,
						 whole_subtree);
	}

	if (pci_is_root_bus(bus))
		return;

	if ((bus->self->class >> 8) != PCI_CLASS_BRIDGE_PCI)
		return;

	if ((rel_type == whole_subtree) || is_leaf_bridge)
		pci_bridge_release_resources(bus, type);

3.3.1 pci_bridge_release_resources()
===============================================================================
; bus    the pci bus which I want to release the resource
; type   the resource type we want to release
pci_bridge_release_resources(struct pci_bus *bus,
					  unsigned long type)
	int idx;
	bool changed = false;
	struct pci_dev *dev;
	struct resource *r;
	unsigned long type_mask = IORESOURCE_IO | IORESOURCE_MEM |
				  IORESOURCE_PREFETCH;

	; dev points to the bridge which introduce the pci bus
	dev = bus->self;
	; just go through the resouces of a bridge which are the io/mem
	; base and limit, and which control the io/mem transaction forward
	for (idx = PCI_BRIDGE_RESOURCES; idx <= PCI_BRIDGE_RESOURCE_END;
	     idx++) {
		r = &dev->resource[idx];
		; this is the type we are trying to release?
		if ((r->flags & type_mask) != type)
			continue;
		if (!r->parent)
			continue;
		/*
		 * if there are children under that, we should release them
		 *  all
		 */
		release_child_resources(r);
		if (!release_resource(r)) {
			dev_printk(KERN_DEBUG, &dev->dev,
				 "resource %d %pR released\n", idx, r);
			/* keep the old size */
			r->end = resource_size(r) - 1;
			r->start = 0;
			r->flags = 0;
			changed = true;
		}
	}

	if (changed) {
		/* avoiding touch the one without PREF */
		if (type & IORESOURCE_PREFETCH)
			type = IORESOURCE_PREFETCH;
		__pci_setup_bridge(bus, type);
	}

3.4 pci_enable_bridges(), traverse the bus and enable the bridges
===============================================================================
pci_enable_bridges(struct pci_bus *bus)
	struct pci_dev *dev;
	int retval;

	list_for_each_entry(dev, &bus->devices, bus_list) {
		; dev->subordinate is not null means the dev is a pci bridge
		if (dev->subordinate) {
			if (!pci_is_enabled(dev)) {
				retval = pci_enable_device(dev);
				if (retval)
					dev_err(&dev->dev, "Error enabling bridge (%d), continuing\n", retval);
				pci_set_master(dev);
			}
			; go down to the child bus
			pci_enable_bridges(dev->subordinate);
		}
	}

3.4.1 pci_enable_device(), enable the BARs
===============================================================================
int pci_enable_device(struct pci_dev *dev)
{
	return __pci_enable_device_flags(dev, IORESOURCE_MEM | IORESOURCE_IO);
}

static int __pci_enable_device_flags(struct pci_dev *dev,
				     resource_size_t flags)
{
	int err;
	int i, bars = 0;

	/*
	 * Power state could be unknown at this point, either due to a fresh
	 * boot or a device removal call.  So get the current power state
	 * so that things like MSI message writing will behave as expected
	 * (e.g. if the device really is in D0 at enable time).
	 */
	if (dev->pm_cap) {
		u16 pmcsr;
		pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pmcsr);
		dev->current_state = (pmcsr & PCI_PM_CTRL_STATE_MASK);
	}

	if (atomic_add_return(1, &dev->enable_cnt) > 1)
		return 0;		/* already enabled */

	/* only skip sriov related */
	for (i = 0; i <= PCI_ROM_RESOURCE; i++)
		if (dev->resource[i].flags & flags)
			bars |= (1 << i);
	for (i = PCI_BRIDGE_RESOURCES; i < DEVICE_COUNT_RESOURCE; i++)
		if (dev->resource[i].flags & flags)
			bars |= (1 << i);

	err = do_pci_enable_device(dev, bars);
	if (err < 0)
		atomic_dec(&dev->enable_cnt);
	return err;
}

3.4.2 do_pci_enable_device(), enable the BARs with given mask
===============================================================================
do_pci_enable_device(struct pci_dev *dev, int bars)
	int err;

	err = pci_set_power_state(dev, PCI_D0);
	if (err < 0 && err != -EIO)
		return err;
	err = pcibios_enable_device(dev, bars);
	if (err < 0)
		return err;
	pci_fixup_device(pci_fixup_enable, dev);

	return 0;

3.5 pci_bus_dump_resources()
===============================================================================
pci_bus_dump_resources(struct pci_bus *bus)
	struct pci_bus *b;
	struct pci_dev *dev;


	pci_bus_dump_res(bus);

	list_for_each_entry(dev, &bus->devices, bus_list) {
		b = dev->subordinate;
		if (!b)
			continue;

		pci_bus_dump_resources(b);
	}

3.5.1 pci_bus_dump_res()
===============================================================================
pci_bus_dump_res(struct pci_bus *bus)
	struct resource *res;
	int i;

	pci_bus_for_each_resource(bus, res, i) {
		if (!res || !res->end || !res->flags)
                        continue;

		dev_printk(KERN_DEBUG, &bus->dev, "resource %d %pR\n", i, res);
        }

4. pci_bus_add_devices(), go throught the root bus, form the pci bus tree and add devices
===============================================================================
 * Add newly discovered PCI devices (which are on the bus->devices
 * list) to the global PCI device list, add the sysfs and procfs
 * entries.  Where a bridge is found, add the discovered bus to
 * the parents list of child buses, and recurse (breadth-first
 * to be compatible with 2.4)

 ; this function will call list_add_tail() to connect the bus with its parent

pci_bus_add_devices(const struct pci_bus *bus)
 	; go throught the devices just under current bus
	; and add to system
	list_for_each_entry(dev, &bus->devices, bus_list) {
		/* Skip already-added devices */
		if (dev->is_added)
			continue;
		retval = pci_bus_add_device(dev);
		if (retval)
			dev_err(&dev->dev, "Error adding device, continuing\n");
	}

	list_for_each_entry(dev, &bus->devices, bus_list) {
		BUG_ON(!dev->is_added);

		child = dev->subordinate;
		/*
		 * If there is an unattached subordinate bus, attach
		 * it and then scan for unattached PCI devices.
		 */
		if (!child)
			continue;
		; add child to parent->children
		; here we form a pci bus tree
		if (list_empty(&child->node)) {
			down_write(&pci_bus_sem);
			list_add_tail(&child->node, &dev->bus->children);
			up_write(&pci_bus_sem);
		}
		pci_bus_add_devices(child);

		/*
		 * register the bus with sysfs as the parent is now
		 * properly registered.
		 */
		if (child->is_added)
			continue;
		retval = pci_bus_add_child(child);
		if (retval)
			dev_err(&dev->dev, "Error adding bus, continuing\n");
	}

4.1 pci_bus_add_device(), register pci_dev->dev, create sysfs entry
===============================================================================
pci_bus_add_device(struct pci_dev *dev)
	retval = device_add(&dev->dev);
	if (retval)
		return retval;

	dev->is_added = 1;
	pci_proc_attach_device(dev);
	pci_create_sysfs_dev_files(dev);
	return 0;

4.2 pci_bus_add_child(), register the bus->dev, create sysfs entry
===============================================================================
pci_bus_add_child(struct pci_bus *bus)
	if (bus->bridge)
		bus->dev.parent = bus->bridge;

	retval = device_register(&bus->dev);
	if (retval)
		return retval;

	bus->is_added = 1;

	/* Create legacy_io and legacy_mem files for this bus */
	pci_create_legacy_files(bus);

	return retval;

5. pci_find_bus(), find the bus with given domain and bus number
===============================================================================
pci_find_bus(int domain, int busnr)
	; go through all root buses
	while ((bus = pci_find_next_bus(bus)) != NULL)  {
		if (pci_domain_nr(bus) != domain)
			continue;
		; go through the domain
		tmp_bus = pci_do_find_bus(bus, busnr);
		if (tmp_bus)
			return tmp_bus;
	}
	return NULL;

5.1 pci_find_next_bus(), find a next pci bus start from "from"
===============================================================================
; One pci root bus represent a pci domain
; the pci root bus are linked list, pci_root_buses

pci_find_next_bus(struct pci_bus *from)
	; if from is null, we start from the beginning of pci_root_buses
	; if from is not null, we follow this from
	; hmm... I think the bus with the same parent will be on the same list
	n = from ? from->node.next : pci_root_buses.next;

	; n == &pci_root_buses means we have visited all the root bus
	if (n != &pci_root_buses)
		b = pci_bus_b(n);
	return b;

5.2 pci_do_find_bus(), traverse the pci tree and find the bus with busnr
===============================================================================
pci_do_find_bus(struct pci_bus *bus, unsigned char busnr)
	if(bus->number == busnr)
		return bus;

	list_for_each(tmp, &bus->children) {
		child = pci_do_find_bus(pci_bus_b(tmp), busnr);
		if(child)
			return child;
	}
	return NULL;

6. __pci_read_base(), read the BAR in config space, set to pci_dev->resource[]
===============================================================================
; this function is used to retrieve the information in the BAR of a pci device
; and convert the information to a resource structure
; this process is split into two steps
; 1. read the raw data from BAR, this is the pci address space
; 2. convert it to cpu address, by pcibios_bus_to_resource()

; pos is the position in the configuration space
__pci_read_base(struct pci_dev *dev, enum pci_bar_type type,
			struct resource *res, unsigned int pos)
	u32 l, sz, mask;
	u16 orig_cmd;
	struct pci_bus_region region;

	mask = type ? PCI_ROM_ADDRESS_MASK : ~0;

	if (!dev->mmio_always_on) {
		pci_read_config_word(dev, PCI_COMMAND, &orig_cmd);
		pci_write_config_word(dev, PCI_COMMAND,
			orig_cmd & ~(PCI_COMMAND_MEMORY | PCI_COMMAND_IO));
	}

	res->name = pci_name(dev);

	pci_read_config_dword(dev, pos, &l);
	pci_write_config_dword(dev, pos, l | mask);
	pci_read_config_dword(dev, pos, &sz);
	pci_write_config_dword(dev, pos, l);

	/*
	 * All bits set in sz means the device isn't working properly.
	 * If the BAR isn't implemented, all bits must be 0.  If it's a
	 * memory BAR or a ROM, bit 0 must be clear; if it's an io BAR, bit
	 * 1 must be clear.
	 */
	if (!sz || sz == 0xffffffff)
		goto fail;

	/*
	 * I don't know how l can have all bits set.  Copied from old code.
	 * Maybe it fixes a bug on some ancient platform.
	 */
	if (l == 0xffffffff)
		l = 0;

	if (type == pci_bar_unknown) {
		res->flags = decode_bar(dev, l);
		res->flags |= IORESOURCE_SIZEALIGN;
		if (res->flags & IORESOURCE_IO) {
			l &= PCI_BASE_ADDRESS_IO_MASK;
			mask = PCI_BASE_ADDRESS_IO_MASK & (u32) IO_SPACE_LIMIT;
		} else {
			l &= PCI_BASE_ADDRESS_MEM_MASK;
			mask = (u32)PCI_BASE_ADDRESS_MEM_MASK;
		}
	} else {
		res->flags |= (l & IORESOURCE_ROM_ENABLE);
		l &= PCI_ROM_ADDRESS_MASK;
		mask = (u32)PCI_ROM_ADDRESS_MASK;
	}

	if (res->flags & IORESOURCE_MEM_64) {
		u64 l64 = l;
		u64 sz64 = sz;
		u64 mask64 = mask | (u64)~0 << 32;

		pci_read_config_dword(dev, pos + 4, &l);
		pci_write_config_dword(dev, pos + 4, ~0);
		pci_read_config_dword(dev, pos + 4, &sz);
		pci_write_config_dword(dev, pos + 4, l);

		l64 |= ((u64)l << 32);
		sz64 |= ((u64)sz << 32);

		sz64 = pci_size(l64, sz64, mask64);

		if (!sz64)
			goto fail;

		if ((sizeof(resource_size_t) < 8) && (sz64 > 0x100000000ULL)) {
			dev_err(&dev->dev, "reg %x: can't handle 64-bit BAR\n",
				pos);
			goto fail;
		}

		if ((sizeof(resource_size_t) < 8) && l) {
			/* Address above 32-bit boundary; disable the BAR */
			pci_write_config_dword(dev, pos, 0);
			pci_write_config_dword(dev, pos + 4, 0);
			region.start = 0;
			region.end = sz64;
			pcibios_bus_to_resource(dev, res, &region);
		} else {
			region.start = l64;
			region.end = l64 + sz64;
			pcibios_bus_to_resource(dev, res, &region);
			dev_printk(KERN_DEBUG, &dev->dev, "reg %x: %pR\n",
				   pos, res);
		}
	} else {
		sz = pci_size(l, sz, mask);

		if (!sz)
			goto fail;

		region.start = l;
		region.end = l + sz;
		pcibios_bus_to_resource(dev, res, &region);

		dev_printk(KERN_DEBUG, &dev->dev, "reg %x: %pR\n", pos, res);
	}

 out:
	if (!dev->mmio_always_on)
		pci_write_config_word(dev, PCI_COMMAND, orig_cmd);

	return (res->flags & IORESOURCE_MEM_64) ? 1 : 0;
 fail:
	res->flags = 0;
	goto out;

6.1 pcibios_bus_to_resource() 
===============================================================================
; calculate CPU address of BAR, set to pci_dev->resource
pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
		strutct pci_bus_region *region)
	struct pci_host_bridge *bridge = pci_host_bridge(dev);
	struct pci_host_bridge_window *window;
	struct pci_bus_region bus_region;
	resource_size_t offset = 0;

	; go throught the bridge window list
	; find the offset
	list_for_each_entry(window, &bridge->windows, list) {
		if (resource_type(res) != resource_type(window->res))
			continue;

		bus_region.start = window->res->start - window->offset;
		bus_region.end = window->res->end - window->offset;

		if (region_contains(&bus_region, region)) {
			offset = window->offset;
			break;
		}
	}

	; set the real CPU address to pci_dev->resource
	res->start = region->start + offset;
	res->end = region->end + offset;

7. pci_read_bridge_bases(), for a bridge set its io/mem window
===============================================================================
pci_read_bridge_bases(struct pci_bus *child)
	struct pci_dev *dev = child->self;
	struct resource *res;
	int i;

	if (pci_is_root_bus(child))	/* It's a host bus, nothing to read */
		return;

	pci_bus_remove_resources(child);
	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++)
		child->resource[i] = &dev->resource[PCI_BRIDGE_RESOURCES+i];

	pci_read_bridge_io(child);
	pci_read_bridge_mmio(child);
	pci_read_bridge_mmio_pref(child);

	; if this is a transparent bridge, use his parent res
	if (dev->transparent) {
		pci_bus_for_each_resource(child->parent, res, i) {
			if (res) {
				pci_bus_add_resource(child, res,
						     PCI_SUBTRACTIVE_DECODE);
				dev_printk(KERN_DEBUG, &dev->dev,
					   "  bridge window %pR (subtractive decode)\n",
					   res);
			}
		}
	}

7.1 pci_bus_remove_resources(), clean up the resource list
===============================================================================
pci_bus_remove_resources(struct pci_bus *bus)
	int i;

	for (i = 0; i < PCI_BRIDGE_RESOURCE_NUM; i++)
		bus->resource[i] = NULL;

	; release the list of bus->resources
	pci_free_resource_list(&bus->resources);


7.2 pci_read_bridge_io(), get io limit
===============================================================================
pci_read_bridge_io(struct pci_bus *child)
	struct pci_dev *dev = child->self;

	res = child->resource[0];
	pci_read_config_byte(dev, PCI_IO_BASE, &io_base_lo);
	pci_read_config_byte(dev, PCI_IO_LIMIT, &io_limit_lo);
	base = (io_base_lo & PCI_IO_RANGE_MASK) << 8;
	limit = (io_limit_lo & PCI_IO_RANGE_MASK) << 8;

	if ((io_base_lo & PCI_IO_RANGE_TYPE_MASK) == PCI_IO_RANGE_TYPE_32) {
		u16 io_base_hi, io_limit_hi;
		pci_read_config_word(dev, PCI_IO_BASE_UPPER16, &io_base_hi);
		pci_read_config_word(dev, PCI_IO_LIMIT_UPPER16, &io_limit_hi);
		base |= (io_base_hi << 16);
		limit |= (io_limit_hi << 16);
	}

	if (base && base <= limit) {
		res->flags = (io_base_lo & PCI_IO_RANGE_TYPE_MASK) | IORESOURCE_IO;
		res2.flags = res->flags;
		region.start = base;
		region.end = limit + 0xfff;
		pcibios_bus_to_resource(dev, &res2, &region);
		if (!res->start)
			res->start = res2.start;
		if (!res->end)
			res->end = res2.end;
		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
	}

7.3 pci_read_bridge_mmio(), get mem limit
===============================================================================
pci_read_bridge_mmio(struct pci_bus *child)
	struct pci_dev *dev = child->self;

	res = child->resource[1];
	pci_read_config_word(dev, PCI_MEMORY_BASE, &mem_base_lo);
	pci_read_config_word(dev, PCI_MEMORY_LIMIT, &mem_limit_lo);
	base = (mem_base_lo & PCI_MEMORY_RANGE_MASK) << 16;
	limit = (mem_limit_lo & PCI_MEMORY_RANGE_MASK) << 16;
	if (base && base <= limit) {
		res->flags = (mem_base_lo & PCI_MEMORY_RANGE_TYPE_MASK) | IORESOURCE_MEM;
		region.start = base;
		region.end = limit + 0xfffff;
		pcibios_bus_to_resource(dev, res, &region);
		dev_printk(KERN_DEBUG, &dev->dev, "  bridge window %pR\n", res);
	}

7.4 pci_read_bridge_mmio_pref(), get mem pref limit
===============================================================================

8. pcie_bus_configure_settings()
===============================================================================
pcie_bus_configure_settings(struct pci_bus *bus, u8 mpss)
	if (!pci_is_pcie(bus->self))
		return;

	if (pcie_bus_config == PCIE_BUS_TUNE_OFF)
		return;

	/* FIXME - Peer to peer DMA is possible, though the endpoint would need
	 * to be aware to the MPS of the destination.  To work around this,
	 * simply force the MPS of the entire system to the smallest possible.
	 */
	if (pcie_bus_config == PCIE_BUS_PEER2PEER)
		smpss = 0;

	if (pcie_bus_config == PCIE_BUS_SAFE) {
		smpss = mpss;

		pcie_find_smpss(bus->self, &smpss);
		pci_walk_bus(bus, pcie_find_smpss, &smpss);
	}

	pcie_bus_configure_set(bus->self, &smpss);
	pci_walk_bus(bus, pcie_bus_configure_set, &smpss);

8.1 pcie_find_smpss()
===============================================================================
pcie_find_smpss(struct pci_dev *dev, void *data)

8.2 pci_walk_bus(), walk devices on/under bus, calling callback
===============================================================================
pci_walk_bus(struct pci_bus *top, int(*cb)(struct pci_dev *, void *),
		void *userdata)
	bus = top;
	next = top->devices.next;
	for (;;) {
		if (next == &bus->devices) {; meet the end of bus->devices
			/* end of this bus, go up or finish */
			if (bus == top)
				break;
			next = bus->self->bus_list.next;
			bus = bus->self->bus;
			continue;
		}
		dev = list_entry(next, struct pci_dev, bus_list);
		if (dev->subordinate) {
			/* this is a pci-pci bridge, do its devices next */
			next = dev->subordinate->devices.next;
			bus = dev->subordinate;
		} else
			next = dev->bus_list.next;

		/* Run device routines with the device locked */
		device_lock(&dev->dev);
		retval = cb(dev, userdata);
		device_unlock(&dev->dev);
		if (retval)
			break;
	}

9. pci_assign_resource(), assign one resource specified by resno of a pci device
===============================================================================
; with a given device and resource index(resno), try to register it on a parent resource
; and if this succeed, apply this to the hardware
pci_assign_resource(struct pci_dev *dev, int resno)
	struct resource *res = dev->resource + resno;
	resource_size_t align, size;
	struct pci_bus *bus;
	int ret;

	align = pci_resource_alignment(dev, res);
	if (!align) {
		dev_info(&dev->dev, "BAR %d: can't assign %pR "
			 "(bogus alignment)\n", resno, res);
		return -EINVAL;
	}

	bus = dev->bus;
	size = resource_size(res);
	ret = _pci_assign_resource(dev, resno, size, align);

	/*
	 * If we failed to assign anything, let's try the address
	 * where firmware left it.  That at least has a chance of
	 * working, which is better than just leaving it disabled.
	 */
	if (ret < 0)
		ret = pci_revert_fw_address(res, dev, resno, size);

	; the assignment is successful
	; apply it to the hardware
	if (!ret) {
		res->flags &= ~IORESOURCE_STARTALIGN;
		dev_info(&dev->dev, "BAR %d: assigned %pR\n", resno, res);
		; update to hardware, not include the bridge resource?
		; the bridge resource will be updated to hardware by
		; pci_setup_bridge()
		if (resno < PCI_BRIDGE_RESOURCES)
			pci_update_resource(dev, resno);
	}
	return ret;

9.1 _pci_assign_resource()
===============================================================================
; dev       point to the particular pci device
; resno     is the resource index
; size      is the resource size
; min_align 
_pci_assign_resource(struct pci_dev *dev, int resno, int size, resource_size_t min_align)
	struct resource *res = dev->resource + resno;
	struct pci_bus *bus;
	int ret;
	char *type;

	bus = dev->bus;
	; try to assign from its parent, if its parent is transparent
	while ((ret = __pci_assign_resource(bus, dev, resno, size, min_align))) {
		if (!bus->parent || !bus->self->transparent)
			break;
		bus = bus->parent;
	}

	; prompt an error log if the resource can't be assigned
	if (ret) {
		if (res->flags & IORESOURCE_MEM)
			if (res->flags & IORESOURCE_PREFETCH)
				type = "mem pref";
			else
				type = "mem";
		else if (res->flags & IORESOURCE_IO)
			type = "io";
		else
			type = "unknown";
		dev_info(&dev->dev,
			 "BAR %d: can't assign %s (size %#llx)\n",
			 resno, type, (unsigned long long) resource_size(res));
	}

	return ret;

9.1.1 __pci_assign_resource()
===============================================================================
; bus       the pci bus which the device attached to
; dev       point to the particular pci device
; resno     is the resource index
; size      is the resource size
; min_align 
__pci_assign_resource(struct pci_bus *bus, struct pci_dev *dev,
		int resno, resource_size_t size, resource_size_t align)
	struct resource *res = dev->resource + resno;
	resource_size_t min;
	int ret;

	; the lower bondery is set according to its type
	min = (res->flags & IORESOURCE_IO) ? PCIBIOS_MIN_IO : PCIBIOS_MIN_MEM;

	/* First, try exact prefetching match.. */
	ret = pci_bus_alloc_resource(bus, res, size, align, min,
				     IORESOURCE_PREFETCH,
				     pcibios_align_resource, dev);

	if (ret < 0 && (res->flags & IORESOURCE_PREFETCH)) {
		/*
		 * That failed.
		 *
		 * But a prefetching area can handle a non-prefetching
		 * window (it will just not perform as well).
		 */
		ret = pci_bus_alloc_resource(bus, res, size, align, min, 0,
					     pcibios_align_resource, dev);
	}
	return ret;

9.1.1.1 pci_bus_alloc_resource()
===============================================================================
; bus         on wich bus you want to assign the resource
; res         which one you want to assign
; size        the resource size
; align       the alignment
; min         the minimal size
; type_mask   the bit mask indicate the exact match 
; alignf 
; alignf_data
pci_bus_alloc_resource(struct pci_bus *bus, struct resource *res,
		resource_size_t size, resource_size_t align,
		resource_size_t min, unsigned int type_mask,
		resource_size_t (*alignf)(void *,
					  const struct resource *,
					  resource_size_t,
					  resource_size_t),
		void *alignf_data)
	int i, ret = -ENOMEM;
	struct resource *r;
	resource_size_t max = -1;

	type_mask |= IORESOURCE_IO | IORESOURCE_MEM;

	/* don't allocate too high if the pref mem doesn't support 64bit*/
	if (!(res->flags & IORESOURCE_MEM_64))
		max = PCIBIOS_MAX_MEM_32;

	; go throught the bus's resource and find which one matches
	pci_bus_for_each_resource(bus, r, i) {
		if (!r)
			continue;

		/* type_mask must match */
		if ((res->flags ^ r->flags) & type_mask)
			continue;

		/* We cannot allocate a non-prefetching resource
		   from a pre-fetching area */
		if ((r->flags & IORESOURCE_PREFETCH) &&
		    !(res->flags & IORESOURCE_PREFETCH))
			continue;

		/* Ok, try it out.. */
		ret = allocate_resource(r, res, size,
					r->start ? : min,
					max, align,
					alignf, alignf_data);
		if (ret == 0)
			break;
	}
	return ret;
 
10. pci_reassign_resource(), assign additional resource request
===============================================================================
; dev     point to the pci device
; resno   index of the resource
; addsize additional resource size
; min_align
pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsize,
			resource_size_t min_align)
	struct resource *res = dev->resource + resno;
	resource_size_t new_size;
	int ret;

	; no parent? bad
	if (!res->parent) {
		dev_info(&dev->dev, "BAR %d: can't reassign an unassigned resource %pR "
			 "\n", resno, res);
		return -EINVAL;
	}

	/* already aligned with min_align */
	new_size = resource_size(res) + addsize;
	ret = _pci_assign_resource(dev, resno, new_size, min_align);
	if (!ret) {
		res->flags &= ~IORESOURCE_STARTALIGN;
		dev_info(&dev->dev, "BAR %d: reassigned %pR\n", resno, res);
		if (resno < PCI_BRIDGE_RESOURCES)
			pci_update_resource(dev, resno);
	}
	return ret;

11. pci_update_resource(), write resource info into physical bar
===============================================================================
pci_update_resource(struct pci_dev *dev, int resno)
	struct resource *res = dev->resource + resno;
	pcibios_resource_to_bus(dev, &region, res);
	new = region.start | (res->flags & PCI_REGION_FLAG_MASK);
	if (res->flags & IORESOURCE_IO)
		mask = (u32)PCI_BASE_ADDRESS_IO_MASK;
	else
		mask = (u32)PCI_BASE_ADDRESS_MEM_MASK;

	; calculate reg for the real offset in config space
	reg = pci_resource_bar(dev, resno, &type);

	pci_write_config_dword(dev, reg, new);
	pci_read_config_dword(dev, reg, &check);

11.1 pci_resouce_bar(), retrieve the bar offset in config space 
===============================================================================
; well, seems it do not take care of the bridge's resource
pci_resource_bar(struct pci_dev *dev, int resno, enum pci_bar_type *type)
	int reg;

	if (resno < PCI_ROM_RESOURCE) {
		*type = pci_bar_unknown;
		return PCI_BASE_ADDRESS_0 + 4 * resno;
	} else if (resno == PCI_ROM_RESOURCE) {
		*type = pci_bar_mem32;
		return dev->rom_base_reg;
	} else if (resno < PCI_BRIDGE_RESOURCES) {
		/* device specific resource */
		reg = pci_iov_resource_bar(dev, resno, type);
		if (reg)
			return reg;
	}

	dev_err(&dev->dev, "BAR %d: invalid resource\n", resno);
	return 0;

12. pci_setup_bridge(), this is used to apply the bridge resource to hardware
===============================================================================
pci_setup_bridge(struct pci_bus *bus)
	unsigned long type = IORESOURCE_IO | IORESOURCE_MEM |
				  IORESOURCE_PREFETCH;

	__pci_setup_bridge(bus, type);

12.1 __pci_setup_bridge()
===============================================================================
static void __pci_setup_bridge(struct pci_bus *bus, unsigned long type)
{
	struct pci_dev *bridge = bus->self;

	dev_info(&bridge->dev, "PCI bridge to [bus %02x-%02x]\n",
		 bus->secondary, bus->subordinate);

	if (type & IORESOURCE_IO)
		pci_setup_bridge_io(bus);

	if (type & IORESOURCE_MEM)
		pci_setup_bridge_mmio(bus);

	if (type & IORESOURCE_PREFETCH)
		pci_setup_bridge_mmio_pref(bus);

	pci_write_config_word(bridge, PCI_BRIDGE_CONTROL, bus->bridge_ctl);
}

13. pci_enable_resources()
===============================================================================
pci_enable_resources(struct pci_dev *dev, int mask)
	u16 cmd, old_cmd;
	int i;
	struct resource *r;

	pci_read_config_word(dev, PCI_COMMAND, &cmd);
	old_cmd = cmd;

	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
		if (!(mask & (1 << i)))
			continue;

		r = &dev->resource[i];

		if (!(r->flags & (IORESOURCE_IO | IORESOURCE_MEM)))
			continue;
		if ((i == PCI_ROM_RESOURCE) &&
				(!(r->flags & IORESOURCE_ROM_ENABLE)))
			continue;

		if (!r->parent) {
			dev_err(&dev->dev, "device not available "
				"(can't reserve %pR)\n", r);
			return -EINVAL;
		}

		if (r->flags & IORESOURCE_IO)
			cmd |= PCI_COMMAND_IO;
		if (r->flags & IORESOURCE_MEM)
			cmd |= PCI_COMMAND_MEMORY;
	}

	if (cmd != old_cmd) {
		dev_info(&dev->dev, "enabling device (%04x -> %04x)\n",
			 old_cmd, cmd);
		pci_write_config_word(dev, PCI_COMMAND, cmd);
	}
	return 0;

14. pci_iov_init(), this function is called on pci enumeration to setup sriov
===============================================================================
int pci_iov_init(struct pci_dev *dev)
{
	int pos;

	if (!pci_is_pcie(dev))
		return -ENODEV;

	pos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_SRIOV);
	if (pos)
		return sriov_init(dev, pos);

	return -ENODEV;
}

14.1 sriov_init()
===============================================================================
sriov_init(struct pci_dev *dev, int pos)
{
	int i;
	int rc;
	int nres;
	u32 pgsz;
	u16 ctrl, total, offset, stride;
	struct pci_sriov *iov;
	struct resource *res;
	struct pci_dev *pdev;

	if (dev->pcie_type != PCI_EXP_TYPE_RC_END &&
	    dev->pcie_type != PCI_EXP_TYPE_ENDPOINT)
		return -ENODEV;

	pci_read_config_word(dev, pos + PCI_SRIOV_CTRL, &ctrl);
	if (ctrl & PCI_SRIOV_CTRL_VFE) {
		pci_write_config_word(dev, pos + PCI_SRIOV_CTRL, 0);
		ssleep(1);
	}

	pci_read_config_word(dev, pos + PCI_SRIOV_TOTAL_VF, &total);
	if (!total)
		return 0;

	ctrl = 0;
	list_for_each_entry(pdev, &dev->bus->devices, bus_list)
		if (pdev->is_physfn)
			goto found;

	pdev = NULL;
	if (pci_ari_enabled(dev->bus))
		ctrl |= PCI_SRIOV_CTRL_ARI;

found:
	pci_write_config_word(dev, pos + PCI_SRIOV_CTRL, ctrl);
	pci_read_config_word(dev, pos + PCI_SRIOV_VF_OFFSET, &offset);
	pci_read_config_word(dev, pos + PCI_SRIOV_VF_STRIDE, &stride);
	if (!offset || (total > 1 && !stride))
		return -EIO;

	pci_read_config_dword(dev, pos + PCI_SRIOV_SUP_PGSIZE, &pgsz);
	i = PAGE_SHIFT > 12 ? PAGE_SHIFT - 12 : 0;
	pgsz &= ~((1 << i) - 1);
	if (!pgsz)
		return -EIO;

	pgsz &= ~(pgsz - 1);
	pci_write_config_dword(dev, pos + PCI_SRIOV_SYS_PGSIZE, pgsz);

	nres = 0;
	for (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {
		res = dev->resource + PCI_IOV_RESOURCES + i;
		i += __pci_read_base(dev, pci_bar_unknown, res,
				     pos + PCI_SRIOV_BAR + i * 4);
		if (!res->flags)
			continue;
		if (resource_size(res) & (PAGE_SIZE - 1)) {
			rc = -EIO;
			goto failed;
		}
		res->end = res->start + resource_size(res) * total - 1;
		nres++;
	}

	iov = kzalloc(sizeof(*iov), GFP_KERNEL);
	if (!iov) {
		rc = -ENOMEM;
		goto failed;
	}

	iov->pos = pos;
	iov->nres = nres;
	iov->ctrl = ctrl;
	iov->total = total;
	iov->offset = offset;
	iov->stride = stride;
	iov->pgsz = pgsz;
	iov->self = dev;
	pci_read_config_dword(dev, pos + PCI_SRIOV_CAP, &iov->cap);
	pci_read_config_byte(dev, pos + PCI_SRIOV_FUNC_LINK, &iov->link);
	if (dev->pcie_type == PCI_EXP_TYPE_RC_END)
		iov->link = PCI_DEVFN(PCI_SLOT(dev->devfn), iov->link);

	if (pdev)
		iov->dev = pci_dev_get(pdev);
	else
		iov->dev = dev;

	mutex_init(&iov->lock);

	dev->sriov = iov;
	dev->is_physfn = 1;

	return 0;

failed:
	for (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {
		res = dev->resource + PCI_IOV_RESOURCES + i;
		res->flags = 0;
	}

	return rc;
}

15. pci_enable_sriov(), enable the sriov for the PF
===============================================================================
; this function is called in the driver to generate the VFs
pci_enable_sriov(struct pci_dev *dev, int nr_virtfn)
	might_sleep();

	if (!dev->is_physfn)
		return -ENODEV;

	return sriov_enable(dev, nr_virtfn);

15.1 sriov_enable()
===============================================================================
sriov_enable(struct pci_dev *dev, int nr_virtfn)
	int rc;
	int i, j;
	int nres;
	u16 offset, stride, initial;
	struct resource *res;
	struct pci_dev *pdev;
	struct pci_sriov *iov = dev->sriov;
	int bars = 0;

	; validate the parameters
	if (!nr_virtfn)
		return 0;

	if (iov->nr_virtfn)
		return -EINVAL;

	pci_read_config_word(dev, iov->pos + PCI_SRIOV_INITIAL_VF, &initial);
	if (initial > iov->total ||
	    (!(iov->cap & PCI_SRIOV_CAP_VFM) && (initial != iov->total)))
		return -EIO;

	if (nr_virtfn < 0 || nr_virtfn > iov->total ||
	    (!(iov->cap & PCI_SRIOV_CAP_VFM) && (nr_virtfn > initial)))
		return -EINVAL;

	pci_write_config_word(dev, iov->pos + PCI_SRIOV_NUM_VF, nr_virtfn);
	; retrieve the offset and stride
	pci_read_config_word(dev, iov->pos + PCI_SRIOV_VF_OFFSET, &offset);
	pci_read_config_word(dev, iov->pos + PCI_SRIOV_VF_STRIDE, &stride);
	if (!offset || (nr_virtfn > 1 && !stride))
		return -EIO;

	nres = 0;
	for (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {
		bars |= (1 << (i + PCI_IOV_RESOURCES));
		res = dev->resource + PCI_IOV_RESOURCES + i;
		if (res->parent)
			nres++;
	}
	if (nres != iov->nres) {
		dev_err(&dev->dev, "not enough MMIO resources for SR-IOV\n");
		return -ENOMEM;
	}

	iov->offset = offset;
	iov->stride = stride;

	; check the virtual bus number
	if (virtfn_bus(dev, nr_virtfn - 1) > dev->bus->subordinate) {
		dev_err(&dev->dev, "SR-IOV: bus number out of range\n");
		return -ENOMEM;
	}

	if (pci_enable_resources(dev, bars)) {
		dev_err(&dev->dev, "SR-IOV: IOV BARS not allocated\n");
		return -ENOMEM;
	}

	if (iov->link != dev->devfn) {
		pdev = pci_get_slot(dev->bus, iov->link);
		if (!pdev)
			return -ENODEV;

		pci_dev_put(pdev);

		if (!pdev->is_physfn)
			return -ENODEV;

		rc = sysfs_create_link(&dev->dev.kobj,
					&pdev->dev.kobj, "dep_link");
		if (rc)
			return rc;
	}

	; enable the VF
	iov->ctrl |= PCI_SRIOV_CTRL_VFE | PCI_SRIOV_CTRL_MSE;
	pci_cfg_access_lock(dev);
	pci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, iov->ctrl);
	msleep(100);
	pci_cfg_access_unlock(dev);

	iov->initial = initial;
	if (nr_virtfn < initial)
		initial = nr_virtfn;

	for (i = 0; i < initial; i++) {
		rc = virtfn_add(dev, i, 0);
		if (rc)
			goto failed;
	}

	if (iov->cap & PCI_SRIOV_CAP_VFM) {
		rc = sriov_enable_migration(dev, nr_virtfn);
		if (rc)
			goto failed;
	}

	kobject_uevent(&dev->dev.kobj, KOBJ_CHANGE);
	iov->nr_virtfn = nr_virtfn;

	return 0;

failed:
	for (j = 0; j < i; j++)
		virtfn_remove(dev, j, 0);

	iov->ctrl &= ~(PCI_SRIOV_CTRL_VFE | PCI_SRIOV_CTRL_MSE);
	pci_cfg_access_lock(dev);
	pci_write_config_word(dev, iov->pos + PCI_SRIOV_CTRL, iov->ctrl);
	ssleep(1);
	pci_cfg_access_unlock(dev);

	if (iov->link != dev->devfn)
		sysfs_remove_link(&dev->dev.kobj, "dep_link");

	return rc;

15.1.1 virtfn_add()
===============================================================================
; id starts from 0
virtfn_add(struct pci_dev *dev, int id, int reset)
	int i;
	int rc;
	u64 size;
	char buf[VIRTFN_ID_LEN];
	struct pci_dev *virtfn;
	struct resource *res;
	struct pci_sriov *iov = dev->sriov;

	virtfn = alloc_pci_dev();
	if (!virtfn)
		return -ENOMEM;

	; create the virtual pci_bus
	mutex_lock(&iov->dev->sriov->lock);
	virtfn->bus = virtfn_add_bus(dev->bus, virtfn_bus(dev, id));
	if (!virtfn->bus) {
		kfree(virtfn);
		mutex_unlock(&iov->dev->sriov->lock);
		return -ENOMEM;
	}
	virtfn->devfn = virtfn_devfn(dev, id);
	virtfn->vendor = dev->vendor;
	pci_read_config_word(dev, iov->pos + PCI_SRIOV_VF_DID, &virtfn->device);
	
	; set up the virtual pci_dev
	pci_setup_device(virtfn);
	virtfn->dev.parent = dev->dev.parent;

	; allocate the resources
	for (i = 0; i < PCI_SRIOV_NUM_BARS; i++) {
		res = dev->resource + PCI_IOV_RESOURCES + i;
		if (!res->parent)
			continue;
		virtfn->resource[i].name = pci_name(virtfn);
		virtfn->resource[i].flags = res->flags;
		size = resource_size(res);
		do_div(size, iov->total);
		virtfn->resource[i].start = res->start + size * id;
		virtfn->resource[i].end = virtfn->resource[i].start + size - 1;
		rc = request_resource(res, &virtfn->resource[i]);
		BUG_ON(rc);
	}

	if (reset)
		__pci_reset_function(virtfn);

	pci_device_add(virtfn, virtfn->bus);
	mutex_unlock(&iov->dev->sriov->lock);

	virtfn->physfn = pci_dev_get(dev);
	virtfn->is_virtfn = 1;

	rc = pci_bus_add_device(virtfn);
	if (rc)
		goto failed1;
	sprintf(buf, "virtfn%u", id);
	rc = sysfs_create_link(&dev->dev.kobj, &virtfn->dev.kobj, buf);
	if (rc)
		goto failed1;
	rc = sysfs_create_link(&virtfn->dev.kobj, &dev->dev.kobj, "physfn");
	if (rc)
		goto failed2;

	kobject_uevent(&virtfn->dev.kobj, KOBJ_CHANGE);

	return 0;

failed2:
	sysfs_remove_link(&dev->dev.kobj, buf);
failed1:
	pci_dev_put(dev);
	mutex_lock(&iov->dev->sriov->lock);
	pci_stop_and_remove_bus_device(virtfn);
	virtfn_remove_bus(dev->bus, virtfn_bus(dev, id));
	mutex_unlock(&iov->dev->sriov->lock);

	return rc;


               struct pci_dev
               +------------------------------------+
               |dev(struct device)                  |
               |   parent           ----------------|----+ 
               |   bus = &pci_bus_type              |    |
               +------------------------------------+    |
               |bus(pci_bus) attached to which bus  |    |
               |    bridge(device)                  |<---+ 
               +------------------------------------+    |
               |devfn (device/function number)      |    | 
               |vendor (vendor ID)                  |    | 
               |device (device ID)                  |    | 
               +------------------------------------+    |
               |resource                            |    |
               |    (an array of struct resource)   |    |
               |    retrieve addreess from BAR      |    |
               |                                    |    |
               |                                    |    |
               +------------------------------------+    |
                                                         |
               virtual pci_dev                           |
               +------------------------------------+    |
               |dev(struct device)                  |    |
               |   parent           ----------------|----+ 
               |   bus = &pci_bus_type              |     
               +------------------------------------+     
               |bus(pci_bus) attached to which bus  |     
               |    bridge(device)                  |      
               +------------------------------------+
               |devfn (device/function number)      |      
               |vendor  same as PF's                |      
               |device (device ID)                  |      
               +------------------------------------+
               |resource                            |
               |    use the first 6                 |
               |                                    |
               +------------------------------------+

               Figure 12.1 vitual pci_dev and physical pci_dev

15.1.1.1 virtfn_add_bus(), create the virtual bus for VF
===============================================================================
pci_bus *virtfn_add_bus(struct pci_bus *bus, int busnr)
	int rc;
	struct pci_bus *child;

	if (bus->number == busnr)
		return bus;

	child = pci_find_bus(pci_domain_nr(bus), busnr);
	if (child)
		return child;

	child = pci_add_new_bus(bus, NULL, busnr);
	if (!child)
		return NULL;

	child->subordinate = busnr;
	child->dev.parent = bus->bridge;
	rc = pci_bus_add_child(child);
	if (rc) {
		pci_remove_bus(child);
		return NULL;
	}

	return child;

             -------+---------      Bus 00(pci_bus) <-------------------+
                    |                 +---secondary(00) <---------------|------+
        +-----------+--------+                                          |      |
        |     00:02.0        |P2P bridge(pci_dev)                       |      |
        | PCIe-PCI bridge    |<--------------------------------------------+   |
        +--------------------+                                          |  |   |
        |dev(device)         |<----------------------------------------------+ |
        +---------------------                                          |  | | |
        |subordinate(pci_bus)|----------+                               |  | | |
        +-----------+--------+          |                               |  | | |
                    |                   +------->+--------------------+ |  | | |
                    |                            |parent              |-+  | | |
         +---------------------+  Bus 02(pci_bus)+--------------------+    | | |
         |                     |                 |self(pci_dev)       |----+ | |
     +----v----+           +----v----+           +--------------------+      | |
     | 02:00.0 |           | 02:01.0 |           |bridge(device)      |------+ |                              
     |(pci_dev)|           |(pci_dev)| +----->   +--------------------+        |                              
     +---------+           +---------+ |         |primary             |--------+                              
                                       |         +--------------------+                                       
                                       |         |resource(struct *)  |            
                                       |         |  point to bridge   |
                                       |         +--------------------+
                                       |         |children(list_head) |
                                       |         +---------+----------+
      Virtual Bus 08(pci_bus)          |            ---+---+---+---
      +-------------------+<-----------|---------------+       +---
      |parent             |------------+                
      +-------------------+ 
      |primary            |set to parent.secondary
      |number             | -+
      |                   |  | these two are 
      |subordinate        | -+ the same
      +-------------------+
      |self = NULL        |
      |bridge = NULL      |
      +-------------------+
      |resource[] = NULL  |
      +-------------------+
      |dev.parent         |set to parent.bridge?
      +-------------------+




                     Figure 12.2 virtual bus and physical bus
                     (this is an example, the number could be different)

15.1.2 virtfn_bus(), calculate the bus number for VF
===============================================================================
virtfn_bus(struct pci_dev *dev, int id)
	return dev->bus->number + ((dev->devfn + dev->sriov->offset +
				    dev->sriov->stride * id) >> 8);

16. pci_enable_msi(), called in driver to enable msi
===============================================================================
#define pci_enable_msi(pdev)	pci_enable_msi_block(pdev, 1)
pci_enable_msi_block(struct pci_dev *dev, unsigned int nvec)
	int status, pos, maxvec;
	u16 msgctl;

	pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
	if (!pos)
		return -EINVAL;
	pci_read_config_word(dev, pos + PCI_MSI_FLAGS, &msgctl);
	; maxvec is the available msi number in hardware
	maxvec = 1 << ((msgctl & PCI_MSI_FLAGS_QMASK) >> 1);
	if (nvec > maxvec)
		return maxvec;

	status = pci_msi_check_device(dev, nvec, PCI_CAP_ID_MSI);
	if (status)
		return status;

	WARN_ON(!!dev->msi_enabled);

	/* Check whether driver already requested MSI-X irqs */
	if (dev->msix_enabled) {
		dev_info(&dev->dev, "can't enable MSI "
			 "(MSI-X already enabled)\n");
		return -EINVAL;
	}

	status = msi_capability_init(dev, nvec);
	return status;

16.1 pci_msi_check_device()
===============================================================================
pci_msi_check_device(struct pci_dev *dev, int nvec, int type)
	struct pci_bus *bus;
	int ret;

	/* MSI must be globally enabled and supported by the device */
	if (!pci_msi_enable || !dev || dev->no_msi)
		return -EINVAL;

	/*
	 * You can't ask to have 0 or less MSIs configured.
	 *  a) it's stupid ..
	 *  b) the list manipulation code assumes nvec >= 1.
	 */
	if (nvec < 1)
		return -ERANGE;

	/*
	 * Any bridge which does NOT route MSI transactions from its
	 * secondary bus to its primary bus must set NO_MSI flag on
	 * the secondary pci_bus.
	 * We expect only arch-specific PCI host bus controller driver
	 * or quirks for specific PCI bridges to be setting NO_MSI.
	 */
	for (bus = dev->bus; bus; bus = bus->parent)
		if (bus->bus_flags & PCI_BUS_FLAGS_NO_MSI)
			return -EINVAL;

	ret = arch_msi_check_device(dev, nvec, type);
	if (ret)
		return ret;

	if (!pci_find_capability(dev, type))
		return -EINVAL;

	return 0;

16.2 msi_capability_init()
===============================================================================
msi_capability_init(struct pci_dev *dev, int nvec)
	struct msi_desc *entry;
	int pos, ret;
	u16 control;
	unsigned mask;

	pos = pci_find_capability(dev, PCI_CAP_ID_MSI);
	msi_set_enable(dev, pos, 0);	/* Disable MSI during set up */

	pci_read_config_word(dev, msi_control_reg(pos), &control);
	/* MSI Entry Initialization */
	entry = alloc_msi_entry(dev);
	if (!entry)
		return -ENOMEM;

	entry->msi_attrib.is_msix	= 0;
	entry->msi_attrib.is_64		= is_64bit_address(control);
	entry->msi_attrib.entry_nr	= 0;
	entry->msi_attrib.maskbit	= is_mask_bit_support(control);
	entry->msi_attrib.default_irq	= dev->irq;	/* Save IOAPIC IRQ */
	entry->msi_attrib.pos		= pos;

	entry->mask_pos = msi_mask_reg(pos, entry->msi_attrib.is_64);
	/* All MSIs are unmasked by default, Mask them all */
	if (entry->msi_attrib.maskbit)
		pci_read_config_dword(dev, entry->mask_pos, &entry->masked);
	mask = msi_capable_mask(control);
	msi_mask_irq(entry, mask, mask);

	list_add_tail(&entry->list, &dev->msi_list);

	/* Configure MSI capability structure */
	ret = arch_setup_msi_irqs(dev, nvec, PCI_CAP_ID_MSI);
	if (ret) {
		msi_mask_irq(entry, mask, ~mask);
		free_msi_irqs(dev);
		return ret;
	}

	ret = populate_msi_sysfs(dev);
	if (ret) {
		msi_mask_irq(entry, mask, ~mask);
		free_msi_irqs(dev);
		return ret;
	}

	/* Set MSI enabled bits	 */
	pci_intx_for_msi(dev, 0);
	msi_set_enable(dev, pos, 1);
	dev->msi_enabled = 1;

	dev->irq = entry->irq;
	return 0;
}

17. pci_fixup, for pci stuff there is several fixup functions
===============================================================================

17.1 definition
===============================================================================
In kernel there are following types of fixup functions.

enum pci_fixup_pass {
	pci_fixup_early,	/* Before probing BARs */
	pci_fixup_header,	/* After reading configuration header */
	pci_fixup_final,	/* Final phase of device fixups */
	pci_fixup_enable,	/* pci_enable_device() time */
	pci_fixup_resume,	/* pci_device_resume() */
	pci_fixup_suspend,	/* pci_device_suspend */
	pci_fixup_resume_early, /* pci_device_resume_early() */
};

And the function is defined by these macro which is defined in include/linux/pci.h.
And will be put into specific sections.

#define DECLARE_PCI_FIXUP_EARLY(vendor, device, hook)			\
	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_early,			\
		vendor##device##hook, vendor, device, PCI_ANY_ID, 0, hook)
#define DECLARE_PCI_FIXUP_HEADER(vendor, device, hook)			\
	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_header,			\
		vendor##device##hook, vendor, device, PCI_ANY_ID, 0, hook)
#define DECLARE_PCI_FIXUP_FINAL(vendor, device, hook)			\
	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_final,			\
		vendor##device##hook, vendor, device, PCI_ANY_ID, 0, hook)
#define DECLARE_PCI_FIXUP_ENABLE(vendor, device, hook)			\
	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_enable,			\
		vendor##device##hook, vendor, device, PCI_ANY_ID, 0, hook)
#define DECLARE_PCI_FIXUP_RESUME(vendor, device, hook)			\
	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_resume,			\
		resume##vendor##device##hook, vendor, device,		\
		PCI_ANY_ID, 0, hook)
#define DECLARE_PCI_FIXUP_RESUME_EARLY(vendor, device, hook)		\
	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_resume_early,		\
		resume_early##vendor##device##hook, vendor, device,	\
		PCI_ANY_ID, 0, hook)
#define DECLARE_PCI_FIXUP_SUSPEND(vendor, device, hook)			\
	DECLARE_PCI_FIXUP_SECTION(.pci_fixup_suspend,			\
		suspend##vendor##device##hook, vendor, device,		\
		PCI_ANY_ID, 0, hook)

17.2 how to call
===============================================================================
pci_fixup_device() is used to call those fixup functions.


void pci_fixup_device(enum pci_fixup_pass pass, struct pci_dev *dev)
{
	struct pci_fixup *start, *end;

	switch(pass) {
	case pci_fixup_early:
		start = __start_pci_fixups_early;
		end = __end_pci_fixups_early;
		break;

	case pci_fixup_header:
		start = __start_pci_fixups_header;
		end = __end_pci_fixups_header;
		break;

	case pci_fixup_final:
		start = __start_pci_fixups_final;
		end = __end_pci_fixups_final;
		break;

	case pci_fixup_enable:
		start = __start_pci_fixups_enable;
		end = __end_pci_fixups_enable;
		break;

	case pci_fixup_resume:
		start = __start_pci_fixups_resume;
		end = __end_pci_fixups_resume;
		break;

	case pci_fixup_resume_early:
		start = __start_pci_fixups_resume_early;
		end = __end_pci_fixups_resume_early;
		break;

	case pci_fixup_suspend:
		start = __start_pci_fixups_suspend;
		end = __end_pci_fixups_suspend;
		break;

	default:
		/* stupid compiler warning, you would think with an enum... */
		return;
	}
	pci_do_fixups(dev, start, end);
}

static void pci_do_fixups(struct pci_dev *dev, struct pci_fixup *f,
			  struct pci_fixup *end)
{
	ktime_t calltime;

	for (; f < end; f++)
		if ((f->class == (u32) (dev->class >> f->class_shift) ||
		     f->class == (u32) PCI_ANY_ID) &&
		    (f->vendor == dev->vendor ||
		     f->vendor == (u16) PCI_ANY_ID) &&
		    (f->device == dev->device ||
		     f->device == (u16) PCI_ANY_ID)) {
			calltime = fixup_debug_start(dev, f->hook);
			f->hook(dev);
			fixup_debug_report(dev, calltime, f->hook);
		}
}

0. Figures, internal representation of pci subsystem
===============================================================================
                    
                                   -------+---------Bus 00(pci_bus) 
                                          |                 
                                 +--------+--------+       
                                 |     00:02.0     |      
                                 | PCIe-PCI bridge |
                                 | (pci_dev)       |
                                 +--------+--------+
                                          |                                
                                          |                                
                               +---------------------+    Bus 02(pci_bus)  
                               |                     |                     
                               |                     |                     
                               |                     |                     
                          +----v----+           +----v----+                
                          | 02:00.0 |           | 02:01.0 |                
                          |(pci_dev)|           |(pci_dev)|                
                          +---------+           +---------+

                     Figure 0.1 internal representaion of PCIe/PCE bridge
                                and its child bus and devices
                     (this is an example, the number could be different)
         

                                      ^
                                      |
      +-------------------------------|--------------------------------+
      |                               |                                |
      |                          +----+----+                           |
      |                          | virtual |                           |
      |                          | PCI-PCI | (pci_dev)                 |
      |                          | bridge  |                           |
      |                          +----+----+                           |
      |                               |                                |
      |                               |Bus#3(pci_bus)                  |
      |                               |                                |
      |          +----------------------------------------+            |
      |          |                    |                   |            |
      |          |                    |                   |            |
      |          |03:00.0             |03:01.0            |03:02.0     |
      |     +----+----+          +----+----+         +----++---+       |
      |     | virtual |          | virtual |         | virtual |       |
      |     | PCI-PCI |pci_dev   | PCI-PCI |pci_dev  | PCI-PCI |pci_dev|
      |     | bridge  |          | bridge  |         | bridge  |       |
      |     +----+----+          +----+----+         +----+----+       |
      |          |                    |                   |            |
      |          |                    |                   |            |
      +----------|--------------------|-------------------|------------+
                 | Bus#4(pci_bus)     | Bus#5(pci_bus)    |Bus#6(pci_bus)
                 v                    v                   v

                   Figure 0.2 internal representation of PCIe Switch
                   (this is an example, the number could be different)

                            Bus 0(pci_bus)                      
                            +--------------------+<----+
                            |children(list_head) |     |
                            |                    |-+   |
                            +--------------------+ |   |
                                                   |   |
                                                   |   |
                    +------------------------------+   |
                    |                                  |
                    |                                  |
                    |        Bridge(pci_dev)           |                     
                    |       +--------------------+<----|---+--------------+
                    |       |subordinate(pci_bus)|-+   |   |              |
                    |       +--------------------+ |   |   |              |
                    |                              |   |   |              |
                    |                              |   |   |              |
                    |       Bus 1(pci_bus)         |   |   |              |
                    +--+--->+-------------------+<-+   |   |              |
                       |    |parent(pci_bus)    |------+   |              |
                       |    +-------------------+          |              |
                       |    |self(pci_dev)      |----------+              |
                       |    |bridge(device)     |                         |
                       |    +-------------------+                         |
                       |    |devices(list_head) |                         |
                       |    +--------+----------+                         |
                       |             |                                    |
                       |      ----+--+---+----                            |
   pci_dev             |          |      |          pci_dev               |
   +---------------+<--|----------+      +--------->+-----------------+   |
   |bus(pci_bus)   |---+                            |bus(pci_bus)     |   |
   +---------------+                                +-----------------+   |
   |dev.parent     |                                |dev.parent       |---+
   +---------------+                                +-----------------+

                  Figure 0.3 relationship between bridge/bus/child device
                  (this is an example, the number could be different
		   another version on web is http://tldp.org/LDP/tlk/dd/pci.html
		   Section 6.6.1)

1. understand the lspci output
===============================================================================

1.1. show the numberic output
===============================================================================
$ lspci -n | head -n 5
0000:00:00.0 0604: 1014:03b9 (rev 10)
0000:01:00.0 0604: 111d:8018 (rev 0e)
0000:02:02.0 0604: 111d:8018 (rev 0e)
0000:02:04.0 0604: 111d:8018 (rev 0e)
0000:20:00.0 0200: 8086:10bc (rev 06)

domain:b:d:f device class: vendor ID: device ID

1.2. convert lspci output to physical layout
===============================================================================
$ lspci -t
-+-[0005:00]---00.0-[01-a0]----00.0-[02-a0]--+-04.0-[20]--
 |                                           +-05.0-[40]--
 |                                           +-06.0-[60]----00.0
 |                                           +-08.0-[80-90]----00.0-[90]--+-01.0
 |                                           |                            +-01.1
 |                                           |                            \-01.2
 |                                           \-09.0-[a0]--
 +-[0004:00]---00.0-[01]--
 +-[0003:00]---00.0-[01]--
 +-[0002:00]---00.0-[01]--
 +-[0001:00]---00.0-[01]--
 \-[0000:00]---00.0-[01-40]----00.0-[02-40]--+-02.0-[20]--+-00.0
                                             |            \-00.1
                                             \-04.0-[40]--+-00.0
                                                          \-00.1

number in the square of a device means the bus number range of the bridge.

$ lspci | grep 0005
0005:00:00.0 PCI bridge: IBM Device 03b9 (rev 10)
0005:01:00.0 PCI bridge: PLX Technology, Inc. PEX 8624 24-lane, 6-Port PCI Express Gen 2 (5.0 GT/s) Switch [ExpressLane] (rev bb)
0005:02:04.0 PCI bridge: PLX Technology, Inc. PEX 8624 24-lane, 6-Port PCI Express Gen 2 (5.0 GT/s) Switch [ExpressLane] (rev bb)
0005:02:05.0 PCI bridge: PLX Technology, Inc. PEX 8624 24-lane, 6-Port PCI Express Gen 2 (5.0 GT/s) Switch [ExpressLane] (rev bb)
0005:02:06.0 PCI bridge: PLX Technology, Inc. PEX 8624 24-lane, 6-Port PCI Express Gen 2 (5.0 GT/s) Switch [ExpressLane] (rev bb)
0005:02:08.0 PCI bridge: PLX Technology, Inc. PEX 8624 24-lane, 6-Port PCI Express Gen 2 (5.0 GT/s) Switch [ExpressLane] (rev bb)
0005:02:09.0 PCI bridge: PLX Technology, Inc. PEX 8624 24-lane, 6-Port PCI Express Gen 2 (5.0 GT/s) Switch [ExpressLane] (rev bb)
0005:60:00.0 RAID bus controller: IBM Obsidian-E PCI-E SCSI controller (rev 01)
0005:80:00.0 PCI bridge: PLX Technology, Inc. PEX8112 x1 Lane PCI Express-to-PCI Bridge (rev aa)
0005:90:01.0 USB Controller: NEC Corporation USB (rev 43)
0005:90:01.1 USB Controller: NEC Corporation USB (rev 43)
0005:90:01.2 USB Controller: NEC Corporation USB 2.0 (rev 04)




                                     --------+---------- Bus #0
                                             |          
                                   +---------+----------+
                                   |IBM Device 00:00.0  |
                                   |           [01-a0]  |
                                   +---------+----------+
                                             |           
                              ---------------+-----------------Bus #1
  Physical Bridge                            |          
  +----------------------------------------------------------------------------------------------------------------+
  |                                          |                                 Internal representation             |
  |                                +---------+----------+                                                          |
  |                                |PLX Bridge 01:00.0  |                                                          |
  |                                |           [02-a0]  |                                                          |
  |                                +---------+----------+                                                          |
  |                                          |                                                                     |
  |   -----+---------------------+-----------+-------+------------------+---------------+-Bus #2                   |
  |        |                     |                   |                  |               |                          |
  | +------+-------+    +--------+------+      +-----+-------+  +-------+----------+  +-+---------------+          |
  | |PLX Bridge    |    |PLX Bridge     |      |PLX Bridge   |  |PLX Bridge        |  |PLX Bridge       |          |
  | |02:04.0 [20]  |    |02:05.0 [40]   |      |02:06.0 [60] |  |02:08.0 [80-90]   |  |02:09.0 [a0]     |          |
  | +------+-------+    +-----+---------+      +----+--------+  +-------+----------+  +-------+---------+          |
  |        |                  |                     |                   |                     |                    |
  +----------------------------------------------------------------------------------------------------------------+
           |                  |                     |                   |                     |                     
       ----+-----Bus#20    ---+----Bus#40        ---+-----Bus#60    ----+------Bus#80 --------+---------Bus#a0      
                                                                        |                                           
                                                                +-------+-----------+                         
                                                                |PLX Bridge 80:00.0 |                         
                                                                |                   |                         
                                                                +-------+-----------+                         
                                                                        |                                     
                                                      -------+----------++---------------+---------Bus#90
                                                             |           |               |               
                                                      +------+------+  +-+---------+  +--+----------+    
                                                      |usb 90:01.0  |  |usb 90:01.1|  |usb 90:01.2  |    
                                                      +-------------+  +-----------+  +-------------+    

